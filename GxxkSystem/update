from mpython import *
import os
import machine
version='1.0.0'
GxxkSystemFileData={
    '/main.py':'# import模块\nfrom mpython import *\nimport time,machine\n\nisUpd=False\nisREPL=False\nd=oled.DispChar\ns=oled.show\nm=machine.reset\nisREPL=button_b.is_pressed()\nisUpd=button_a.is_pressed()\n\ndef drawLine():\n    oled.fill(0);oled.hline(0,15,128,1)\ntry:\n    if not (isUpd+isREPL):\n        drawLine();d("GxxkSystem-Loading...",0,-1);d("加载GxxkSystem中...",0,16)\n        import GxxkSystem.main as m;m.main()\nexcept MemoryError:\n    drawLine();d("GxxkSystem-内存错误",0,-1);d("GxxkSystem发生内存错误，将在3s后重启",0,16,auto_return=True);s();time.sleep(3);m()\nif isREPL:\n    drawLine();d("GxxkSystem-REPL",0,0);s()\nelif isUpd:\n    drawLine();d("GxxkSystem-更新中...",0,-1);d("将从云端下载安装包 完成后进入安 装包界面",0,16,auto_return=True);s();import GxxkSystem.wifi,urequests,GxxkSystem.config as c;c=c.getConfig();GxxkSystem.wifi.connect(c[3],c[4])\n    with open("/main.py",mode="w",encoding="utf-8")as f:f.write(urequests.get(c[2]).text)\n    m()',
    '/GxxkSystem/main.py':'\n# 插件功能使用方法：\n# P上 N下 A确定（查看详细信息） B删除（本地模式）\n\n# 模块导入\nimport GxxkSystem.wifi\nfrom mpython import *\nimport GxxkSystem.ui as ui\nimport machine\nimport os\nimport urequests as requests\nimport time\nimport GxxkSystem.config as config\nimport GxxkSystem.gxxkTyper as gxxkTyper \n\n# 变量定义\nmodes_=["touchPad_P.read()<100 or touchPad_Y.read()<100 or touchPad_T.read()<100 or touchPad_H.read()<100 or touchPad_O.read()<100 or touchPad_N.read()<100",\n    "button_a.is_pressed() or button_b.is_pressed()"]\n\n# 等待函数\ndef wait(mode="0"):\n    global modes_\n    modes=modes_\n    print("[GxxkSystem]等待用户操作...")\n    print("[GxxkSystem]Mode："+mode)\n    if mode=="0":modes=modes[0]+\' or \'+modes[1]  # mode0：触摸按键+按钮\n    elif mode=="1":modes=modes[0]                 # mode1：触摸按键\n    elif mode=="2":modes=modes[1]                 # mode2：按钮\n    else:modes=modes[0]+\' or \'+modes[1]\n    print("[GxxkSystem]判断条件："+modes)\n    while not eval(modes):pass\n    print("[GxxkSystem]用户做出决定")\n\n# 主函数\ndef main():\n    global modes_\n    print("[GxxkSystem]绘制主函数UI")\n    ui.main()\n    wait()\n    if touchPad_P.read()<100 or touchPad_Y.read()<100:#插件商店\n        print("[GxxkSystem]按下P（或Y）触摸按键，进入插件商店")\n        pluginStore()\n    elif touchPad_H.read()<100 or touchPad_T.read()<100:#本地插件\n        print("[GxxkSystem]按下T（或H）触摸按键， 进入本地插件")\n        localPlugin()\n    elif touchPad_O.read()<100 or touchPad_N.read()<100:#设置\n        print("[GxxkSystem]按下O（或N）触摸按键，进入设置界面")\n        setting()\n    elif button_a.is_pressed():#锁屏界面\n        print("[GxxkSystem]进入锁屏界面")        \n        time.sleep(1)\n        lockScreen()\n        print("[GxxkSystem]退出锁屏 界面")\n    else:\n        print("[GxxkSystem]未作出有效决策，等待")\n    main()\n\n# 插件商店\n# 插件列表格式： [["插件名称","插件作者","插件文件名"],["插件名称2","插件作者2","插件文件名2"]...]\ndef pluginStore():\n    global modes_\n    print("[GxxkSystem]进入在线插件商店")\n    print("[GxxkSystem]目录"+os.getcwd())\n    # 判断有没有网络\n    if not GxxkSystem.wifi.isConnect():\n        ui.noConnect()\n        time.sleep(1.5)\n        main()\n    #获取插件列表\n    localPluginList=eval(requests.get(config.getConfig()[1]+"index").text)\n    target=0\n    print("[GxxkSystem]进入插件商店，软件 源 "+config.getConfig()[1]+"   软件源信息 "+str(localPluginList))\n    #主循环\n    while True:\n        print("[GxxkSystem]Target"+str(target))\n        #绘制UI\n        oled.fill(0)\n        oled.hline(0,16,128,1)\n        oled.DispChar("GxxkSystem-插件商店",0,-1)#说实话，这玩意最开始能写-1是我没想到的\n        oled.DispChar(localPluginList[target][0],0,16,2) #反色模式绘制\n        try:\n            oled.DispChar(localPluginList[target+1][0],0,32)\n            oled.DispChar(localPluginList[target+2][0],0,48)\n        except Exception:pass\n        oled.show()\n        #等待操作\n        wait()\n        #做出决策\n        if button_a.is_pressed(): # 查看详细信息\n            print("[GxxkSystem]"+str(target)+" 被选中")  \n            oled.fill(0)\n            ui.drawLine()\n            oled.DispChar("GxxkSystem-插件信息",0,-1)\n            oled.DispChar("名："+localPluginList[target][0],0,16)\n            oled.DispChar("作者："+localPluginList[target][1],0,32)\n            oled.show()\n            #等待做出决策\n            wait()\n            #按任意键返回菜单\n            if button_a.is_pressed():# 获取插件并运行\n                print("[GxxkSystem]获取插件 URL："+config.getConfig()[1]+localPluginList[target][2])\n                print("[GxxkSystem]插件文件 "+localPluginList[target][2])\n                plugin=requests.get(config.getConfig()[1]+localPluginList[target][2]).text\n                with open("/GxxkSystem/GxxkPlugin/"+localPluginList[target][2],mode="w",encoding="utf-8")as f:\n                    f.write(plugin)\n                exec("import GxxkSystem.GxxkPlugin."+localPluginList[target][2][:-3]+" as startTarget")#说实话这个好像颜文字啊哈哈哈\n                exec("startTarget.start()")#和项目管理器里面的运行部分一模一样，不是吗（笑）\n        elif button_b.is_pressed():# 返回到主菜单\n            print("[GxxkSystem]返回主菜单") \n            break\n        elif touchPad_P.read()<100: # 向上（左）\n            target-=1\n        elif touchPad_N.read()<100: # 向下（右）\n            target+=1\n        if target==len(localPluginList): # 当值超出范围时回到正常值，下面一个同理\n            target=0\n        elif target== -1:\n            target=len(localPluginList)-1\n    \n# 本地插件\n# 格式：[[名称,作者,导入的模块名]]\ndef localPlugin():\n    print("[GxxkSystem]进入本地文件")\n    # 切换目录\n    os.chdir("/GxxkSystem/GxxkPlugin/")\n    # 获取插 件信息\n    localPluginList=[i[:-3] for i in os.listdir()]\n    if len(localPluginList)==0:\n        print("[GxxkSystem]本地没有插件，回到主界面")\n        ui.noPlugin()\n        wait()\n        main()\n    print("[GxxkSystem]开始遍历本地文件下的所有内容")\n    for i in range(len(localPluginList)):\n        exec("import {}".format(localPluginList[i]))\n        info=eval(localPluginList[i]+".info")\n        localPluginList[i]=[info[0],info[1],localPluginList[i]]# 这里相当于是 二维列表\n        print("[GxxkSystem]文件名 "+localPluginList[i][2]+" 名称 "+localPluginList[i][0])\n    print("[GxxkSystem]插件列表 "+str(localPluginList))\n    target=0\n    #主循环\n    while True:\n        print("[GxxkSystem]Target"+str(target))\n        #绘制UI\n        oled.fill(0)\n        ui.drawLine()\n        oled.DispChar("GxxkSystem-本地插件",0,-1)\n        oled.DispChar(localPluginList[target][0],0,16,2) #反色模式绘制\n        try:\n            oled.DispChar(localPluginList[target+1][0],0,32)\n            oled.DispChar(localPluginList[target+2][0],0,48)\n        except Exception:pass\n        oled.show()\n        #等待操作\n        wait()\n        #做出决策\n        if button_a.is_pressed(): # 查看详细信息\n            print("[GxxkSystem]被选中")\n            oled.fill(0)\n            ui.drawLine()\n            oled.DispChar("GxxkSystem-插件信息",0,-1)\n            oled.DispChar("名："+localPluginList[target][0],0,16)\n            oled.DispChar("作者："+localPluginList[target][1],0,32)\n            oled.show()\n            #等待做出决策\n            wait()\n            #按任意键返回菜单\n            if button_a.is_pressed():# 运行插件\n                print("[GxxkSystem]运行")\n                exec(localPluginList[target][2]+".start()")\n            elif button_b.is_pressed(): # 删除插 件\n                os.remove("/GxxkSystem/GxxkPlugin/"+localPluginList[target][2]+".py")\n        elif button_b.is_pressed():# 返回到 主菜单\n            break\n        elif touchPad_P.read()<100: # 向上（左）\n            target-=1\n        elif touchPad_N.read()<100: # 向下（右）\n            target+=1\n        if target==len(localPluginList): # 当值超出 范围时回到正常值，下面一个同理\n            target=0\n        elif target== -1:\n            target=len(localPluginList)-1\n\n# 设置\n# 使用 PY TH ON 操作\ndef setting():\n    global modes_\n    print("[GxxkSystem]进入设置页面")\n    ui.setting()\n    wait()\n    if touchPad_P.read()<100 or touchPad_Y.read()<100: # wifi设置\n        print("[GxxkSystem]设置WiFi界面")\n        print("[GxxkSystem]SSID: "+config.getConfig()[3])\n        print("[GxxkSystem]PWD: "+config.getConfig()[4])\n        ui.setting_WiFi()\n        wait()\n        if touchPad_P.read()<100 or touchPad_Y.read()<100: # wifi信息 设置\n            print("[GxxkSystem]设置WiFiSSID")\n            ssid=gxxkTyper.gxxkTyper.main()\n            oled.fill(0)\n            oled.show()\n            time.sleep(0.5)\n            print("[GxxkSystem]设置WiFiPWD")\n            pwd=gxxkTyper.gxxkTyper.main()\n            print("[GxxkSystem]写入设置")\n            config.writeConfig(str(ssid),str(pwd))\n            print("[GxxkSystem]连接WiFi")\n            GxxkSystem.wifi.connect(config.getConfig()[3],config.getConfig()[4])\n        elif touchPad_T.read()<100 or touchPad_H.read()<100: # 连接wifi\n            print("[GxxkSystem]连接WiFi")\n            GxxkSystem.wifi.connect(config.getConfig()[3],config.getConfig()[4])\n        elif touchPad_O.read()<100 or touchPad_N.read()<100: #同步时间\n            print("[GxxkSystem]同步时间")\n            GxxkSystem.wifi.setTime()\n    elif touchPad_T.read()<100 or touchPad_H.read()<100:\n        ui.showText("此功能需要重启后长按A键直到出现提示后松开触发")\n        time.sleep(3)\n        machine.reset()\n    elif touchPad_O.read()<100 or touchPad_N.read()<100:\n        ui.about()\n        wait()\n        main()\n    main()\n\n# 锁屏界面\ndef lockScreen():\n    clock = Clock(oled, 32, 32, 30)\n    rtc=machine.RTC()\n    while not button_a.is_pressed():\n        dt=rtc.datetime()\n        oled.fill(0)\n        clock.settime()\n        clock.drawClock()\n        oled.DispChar(\'GxxkSystem\',60,0)\n        oled.DispChar(\'{}.{}.{}\'.format(dt[0],dt[1],dt[2]),64,16)\n        oled.DispChar(\'{}:{}:{}\'.format(dt[4],dt[5],dt[6]),64,32)\n        oled.DispChar(\'By:0f永蓝\',60,48)\n        oled.show()',
    '/GxxkSystem/gxxkTyper.py':'# GxxkTyper（Gxxk打字机）操作方法\n# ABCDEFGHIJKLMNOP、QRSTUVWXYZ、标点符号、数字0-9各分一组\n# 使用PYTH决定选择的组， 使用O查看已输入字符，A确认，B退格\n# 输入的内容就是[[[ABCD],[EFGH],[IJKL],[MNOP]],[[QRST],[UVWX],[YZ]],[[0123],[4567],[89]],[[-=[]],[\\;\',],[./_+],[[{}|:"],[<>?"]]]\nfrom mpython import *\nimport GxxkSystem.main\nimport time\n\n# 除了最后 一个叠了4层外，其他的都叠了3层\nres2=[["ABCD","EFGH","IJKL","MNOP"],["QRST","UVWX","YZ"],["0123","4567","89"],["_+{}",\'|:"=\',"<>?-",["[]\\;","\',./"," !@#",["[$%^","&*()"]]]]\nres= [["abcd","efgh","ijkl","mnop"],["qrst","uvwx","yz"],["0123","4567","89"],["_+{}",\'|:"=\',"<>?-",["[]\\;","\',./"," !@#",["[$%^","&*()"]]]]\nisUpper=True\n#res_show=["ABCDEFGHIJKLMNOP","QRSTUVWZXYZ","0123456789",\'_+{}|:"<>?-=[]\\;\',./\']\ntemp=None\n\n# 功能：可将某个嵌套列表中指定的一个大项（ 里面嵌套着很多列表的列表）中的每一个小列表合并为字符串\n# 用法：list2str(index=\'[对应列表索引]\')\ndef list2str(list__=\'\',index=\'\'):\n    exec("global "+list__)\n    print("[GxxkSystem]输入界面执行列表转文字，指定内容：res"+str(index))\n    list_=[]\n    print("[GxxkSystem]列表："+str(eval(list__+index)))\n    for i in eval(list__+index): #此处是列表\n        print("[GxxkSystem]第1层循环，"+str(i))\n        str_=\'\'\n        # 如果列表是字符串，那么直接将i添加到列表结尾\n        # str用于指定列表内的嵌套的列表信息组合\n        if type(i)==str:\n            print("[GxxkSystem]第一层循环，对象i为str属性，append到list_  i为"+str(i))\n            list_.append(i)\n        else:\n            # 将列表内的列表进 行遍历，每一项的字符串拼接到str_内，最终再进行append\n            for x in i:\n                if type(x)==str:\n                    print("[GxxkSystem]第2层循环，"+str(x))\n                    str_+=x\n                else:\n                    for j in x:\n                        print("[GxxkSystem]第3层循环，"+str(j))\n                        if type(j)==str:\n                            str_+=j\n                        else:\n                            for k in j:\n                                str_+=k\n                            #res列表最多嵌套4层，所以这里可以添加到临时变量\n            # 结束当前层级循环后添加至列表\n            list_.append(str_)\n    return list_\nclass gxxkTyper():\n    # 组内选 择\n    def group_main(group):\n        global temp,isUpper\n        print("[GxxkSystem]进入输入组选择界面")\n        print("[GxxkSystem]选择输入组")\n        temp=group\n        group_showtext=list2str(list__="temp")\n        # 绘制UI\n        oled.fill(0)\n        # 不直接写4个DispChar是因为有的时候列表只有2个选项\n        for i in range(len(group_showtext)):\n            oled.DispChar(group_showtext[i] if isUpper else group_showtext[i].upper() ,0,i*16)\n        oled.show()\n        # 等待\n        GxxkSystem.main.wait()\n        # 对决策作出判断\n        if touchPad_P.read()<100: \n            #组1\n            print("[GxxkSystem]选择组1")\n            return 0\n        elif touchPad_Y.read()<100 and len(group_showtext)>=2:\n            #组2\n            print("[GxxkSystem]选择组2 ")\n            return 1\n        elif touchPad_T.read()<100 and len(group_showtext)>=3: \n            #组3，多加一个条件是因为部分列表只有3或2个选项，下面也是\n            print("[GxxkSystem]选择组3")\n            return 2\n        elif touchPad_H.read()<100 and len(group_showtext)>=4: \n            #组4\n            print("[GxxkSystem]选择组4")\n            return 3\n        else:\n            print("[GxxkSystem]未作出有效决策，自动返回上一级")\n    # 主程序\n    # 每个字母组、数字组使用group_main输入，设定好对应的组 （group参数来源于str）即可\n    def main(text=""):\n        global res,res2,temp,isUpper\n        list_=res\n        while not button_a.is_pressed(): #如果a按下就跳出循环\n            print("[GxxkSystem]文本  "+text)\n            print("[GxxkSystem]大写状态为"+str(isUpper))\n            if touchPad_O.read()<100:#显示文本\n                print("[GxxkSystem] 选择显示已输入内容，按任意键返回")\n                oled.fill(0)\n                oled.DispChar(text,0,0,auto_return=True)\n                oled.show()\n                GxxkSystem.main.wait()\n            elif touchPad_N.read()<100:#切换大 小写\n                print("[GxxkSystem]切换大小写")\n                isUpper=bool(isUpper-1)\n                time.sleep(0.3)\n            elif button_b.is_pressed():\n                print("[GxxkSystem]退格")\n                text=text[:len(text)-1]#退格\n                time.sleep(0.3)\n            try:\n                userInput=gxxkTyper.group_main(list_)  #先把默认的列表传进去选择，返回值是用户选择的内容的索引\n            except KeyboardInterrupt:\n                userInput=None\n                text=input("[GxxkSystem]请输入要修改的字段：")\n            if userInput==None:#如果未作出 有效决策，就先跳过当前循环，循环开始有 判断语句\n                continue\n            elif type(list_)==str:\n                print("[GxxkSystem] "+list_[userInput]+" 为str，添加至text变量中")\n                if isUpper:text+=list_[userInput].upper()\n                else:text+=list_[userInput]\n                list_=res\n            elif type(list_)==list:\n                print(\'[GxxkSystem] \'+str(list_[userInput])+" 为list，继续进行选择")\n                list_=list_[userInput]\n        print("[GxxkSystem]按下A键 返回")\n        return text',
    '/GxxkSystem/ui.py':'# 话说一般这个文件其实没起太大作用，一般适用于静态页面\nfrom mpython import *\nimport GxxkSystem.wifi\nimport GxxkSystem.config\ndef drawLine():\n    oled.hline(0,15,128,1)\ndef main():\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-主菜单",0,0)\n    drawLine()\n    oled.DispChar("插件商店",0,16)\n    oled.DispChar("已安装插件",0,32)\n    oled.DispChar(" 设置",0,48)\n    oled.show()\ndef noConnect():\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-没有网络",0,0)\n    drawLine()\n    oled.DispChar("未连接WiFi 无法使用此功能",0,16,auto_return=True)\n    oled.show()\ndef setting():\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-设置",0,0)\n    drawLine()\n    oled.DispChar("WiFi设置",0,16)\n    oled.DispChar("更新",0,32)\n    oled.show()\ndef showText(text):\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-信息提示",0,0)\n    drawLine()\n    oled.DispChar(text,0,16,auto_return=True)\n    oled.show()\ndef setting_WiFi():\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-WiFi设置",0,0)\n    drawLine()\n    oled.DispChar("设置WiFi信息",0,16)\n    oled.DispChar("已 连接" if GxxkSystem.wifi.isConnect() else "连接WiFi",0,32)\n    oled.DispChar("同步时间",0,48)\n    oled.show()\ndef noPlugin():\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-没有插件",0,-1)\n    drawLine()\n    oled.DispChar("目前没有存储任何本地插件，请先在插件商店下载插件",0,16,auto_return=True)\n    oled.show()\ndef about():\n    oled.fill(0)\n    oled.DispChar("GxxkSystem-关于",0,-1)\n    drawLine()\n    oled.DispChar("程序、UI：0f永蓝",0,16)\n    oled.DispChar("测试 ：Can1425",0,32)\n    oled.show()',
    '/GxxkSystem/wifi.py':'from mpython import *\nimport network\nimport ntptime\nwifi_ = wifi()\ndef connect(ssid,pwd):\n    wifi_.connectWiFi(ssid,pwd)\ndef isConnect():\n    return wifi_.sta.isconnected()\ndef disconnect():\n    wifi_.disconnectWiFi()\ndef setTime():\n    ntptime.settime(8, "cn.ntp.org.cn")',
    '/GxxkSystem/config.py':'# 配置 配置文件 的文件\n# 第一个：版本号\n# 第二个：插件更新/获取源\n# 第三个：是否显示打印日志\n\ndef getConfig():\n    with open("/GxxkSystem/config",mode="r",encoding="utf-8")as f:\n        return [i.strip("\r") for i in f.read().split("\n")]\ndef writeConfig(index,text):\n    config=getConfig()\n    with open("/GxxkSystem/config",mode="w",encoding="utf-8")as f:\n        for i in range(len(config)):\n            if i==index:\n                f.write(str(text)+"\n")\n            else:\n                f.write(str(config[i])+"\n")',
    '/GxxkSystem/config':'1.0.0\nhttp://ouyanghongqian.top/GxxkSystem/plugin/\nhttp://ouyanghongqian.top/GxxkSystem/update\nTP-108\nlcx19831',
    '/boot.py':''
}
GxxkSystemDir={
    "/":"GxxkSystem",
    "/GxxkSystem/":"GxxkPlugin"
}
def drawLine():
    oled.fill(0);oled.hline(0,16,128,1)
def install():
    global GxxkSystemDir,GxxkSystemFileData
    for i in GxxkSystemDir:
        try:
            os.chdir(i)
            os.mkdir(GxxkSystemDir[i])
        except Exception:pass
    for i in GxxkSystemFileData:
        print("[GxxkSystemInstaller]写入文件："+i)
        with open(i,mode="w",encoding="utf-8")as f:
            f.write(GxxkSystemFileData[i])
def main():
    global version
    drawLine()
    oled.DispChar("GxxkSystem-安装",0,0)
    oled.DispChar("A安装 B进入REPL",0,17)
    oled.DispChar("版本"+version,0,32)
    oled.show()
    while not button_a.is_pressed() or button_b.is_pressed():pass
    if button_a.is_pressed(): 
        print("[GxxkSystemInstaller]开始安装")
        drawLine()
        oled.DispChar("GxxkSystem-安装中...",0,0)
        oled.DispChar("安装中... 请耐心等待 完成后自动重启",0,17,auto_return=True)
        oled.show()
        install()
        print("[GxxkSystemInstaller]安装完成，重启掌控版")
        machine.reset()
    elif button_b.is_pressed():
        print("[GxxkSystemInstaller]进入REPL")
        drawLine()
        oled.DispChar("GxxkSystem-REPL",0,0)
        oled.show()
        oled.fill(0)
if __name__=="__main__":
    print("[GxxkSystemInstaller]掌控版已加载程序")
    main()